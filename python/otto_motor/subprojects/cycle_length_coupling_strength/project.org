#+PROPERTY: header-args :session otto_cycle_length :kernel python :pandoc no :async yes :tangle tangle/cycle_length.py

Here we scan the cycle length and coupling strength.

* Boilerplate
#+name: boilerplate
#+begin_src jupyter-python :results none
    import figsaver as fs
    import plot_utils as pu
    from hiro_models.one_qubit_model import StocProcTolerances
    from hiro_models.otto_cycle import OttoEngine
    import hiro_models.model_auxiliary as aux
    import numpy as np
    import qutip as qt
    import utilities as ut
    import stocproc
    import matplotlib.pyplot as plt
    import otto_utilities as ot

    import ray
    ray.shutdown()

    #ray.init(address='auto')
    ray.init()
    from hops.util.logging_setup import logging_setup
    import logging
    logging_setup(logging.INFO)
    plt.rcParams['figure.figsize'] = (12,4)
#+end_src

* Cycles
We take the same baseline as in [[id:c06111fd-d719-433d-a316-c163f6e1d384][cycle_shift.org]].


But we vary the cycle speed while keeping a fixed proportion
coupling-change/cycle time.
#+begin_src jupyter-python :results none
  def make_model(Θ, δ):
      (p_H, p_L) = ot.timings(.1, .1)

      return OttoEngine(
          δ=[δ, δ],
          ω_c=[2, 2],
          ψ_0=qt.basis([2], [1]),
          description=f"Classic Cycle",
          k_max=5,
          bcf_terms=[6] * 2,
          truncation_scheme="simplex",
          driving_process_tolerances=[StocProcTolerances(1e-3, 1e-3)] * 2,
          thermal_process_tolerances=[StocProcTolerances(1e-3, 1e-3)] * 2,
          T=[0.5, 4],
          therm_methods=["tanhsinh", "tanhsinh"],
          Δ=1,
          num_cycles=3,
          Θ=Θ,
          dt=0.001,
          timings_H=p_H,
          timings_L=p_L,
          streaming_mode=True,
          shift_to_resonance=(False, False),
          L_shift=(0, 0),
      )
#+end_src


#+begin_src jupyter-python
  δs = [round(δ, 3) for δ in np.linspace(.4, .9, 5)]
  Θs = [round(Θ, 3) for Θ in np.linspace(30, .60, 5)]
  δs, Θs
#+end_src

#+RESULTS:
|  0.4 | 0.525 | 0.65 | 0.775 | 0.9 |
| 30.0 | 22.65 | 15.3 |  7.95 | 0.6 |

#+begin_src jupyter-python
  import itertools
  models = [make_model(Θ, δ) for Θ, δ, in itertools.product(Θs, δs)]
#+end_src


* Integrate
#+begin_src jupyter-python
  ot.integrate_online_multi(models, 100_000, increment=10_000, analyze_kwargs=dict(every=10_000))
#+end_src


* Things to Look At
- power and efficiency
- magnitude of interaction energies
- magnitude of interaction powers
