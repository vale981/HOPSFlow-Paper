#+PROPERTY: header-args :session otto_cycle_length :kernel python :pandoc no :async yes :tangle tangle/coupling_strength.py :noweb yes

Here we scan the cycle length and coupling strength.

* Boilerplate
#+name: boilerplate
#+begin_src jupyter-python :results none
    import figsaver as fs
    import plot_utils as pu
    from hiro_models.one_qubit_model import StocProcTolerances
    from hiro_models.otto_cycle import OttoEngine
    import hiro_models.model_auxiliary as aux
    import numpy as np
    import qutip as qt
    import utilities as ut
    import stocproc
    import matplotlib.pyplot as plt
    import otto_utilities as ot

    import ray
    ray.shutdown()

    #ray.init(address='auto')
    ray.init()
    from hops.util.logging_setup import logging_setup
    import logging
    logging_setup(logging.INFO)
    plt.rcParams['figure.figsize'] = (12,4)
#+end_src

* Cycles
We take the same baseline as in [[id:c06111fd-d719-433d-a316-c163f6e1d384][cycle_shift.org]].

But we vary the cycle speed while keeping a fixed proportion
coupling-change/cycle time.
#+NAME: make-model
#+begin_src jupyter-python :results none
  def make_model(Î˜, Î´):
      (p_H, p_L) = ot.timings(.06, .06)
      return OttoEngine(
            Î´=[Î´, Î´],
            Ï‰_c=[1, 1],
            Ïˆ_0=qt.basis([2], [1]),
            description=f"Classic Cycle",
            k_max=4,
            bcf_terms=[5] * 2,
            truncation_scheme="simplex",
            driving_process_tolerances=[StocProcTolerances(1e-3, 1e-3)] * 2,
            thermal_process_tolerances=[StocProcTolerances(1e-3, 1e-3)] * 2,
            T=[0.5, 4],
            therm_methods=["tanhsinh", "tanhsinh"],
            Î”=1,
            num_cycles=3,
            Î˜=Î˜,
            dt=0.001,
            timings_H=p_H,
            timings_L=p_L,
            streaming_mode=True,
            shift_to_resonance=(False, False),
            L_shift=(0, 0),
        )
#+end_src


#+begin_src jupyter-python
  Î´s = [round(Î´, 3) for Î´ in np.linspace(.3, .7, 5)]
  Î˜s = [round(Î˜, 3) for Î˜ in np.linspace(20, 80, 5)][1:]
  Î´s, Î˜s
#+end_src

#+RESULTS:
|  0.3 |  0.4 |  0.5 |  0.6 | 0.7 |
| 35.0 | 50.0 | 65.0 | 80.0 |     |

#+begin_src jupyter-python
  import itertools
  models = [make_model(Î˜, Î´) for Î˜, Î´, in itertools.product(Î˜s, Î´s)]
#+end_src

#+RESULTS:


* Integrate
#+begin_src jupyter-python
  ot.integrate_online_multi(models, 50_000, increment=10_000, analyze_kwargs=dict(every=10_000))
#+end_src


* Analysis
#+begin_src jupyter-python
  ot.plot_energy(models[5])
#+end_src

#+RESULTS:
:RESULTS:
| <Figure | size | 1200x400 | with | 1 | Axes> | <AxesSubplot: | xlabel= | $\tau$ | ylabel= | Energy | > |
[[file:./.ob-jupyter/164cf59963539ffe267c06050906eacc5c84a306.svg]]
:END:

#+begin_src jupyter-python
  for i in range(len(Î˜s)):
    fig, ax = plt.subplots()
    for model in models[len(Î´s) * i :len(Î´s) * (i+1)]:
      pu.plot_with_Ïƒ(model.t, model.system_energy(), ax=ax)
#+end_src

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/e260500c9f6e3ee5bffaa8e55362d765f315dbd9.svg]]
[[file:./.ob-jupyter/b689998cdfdd74781109afb6a523502318876d06.svg]]
[[file:./.ob-jupyter/88fcef6f0d71dbae4e9a3e3cbaa67b1a3db1363c.svg]]
[[file:./.ob-jupyter/73c5fc49ba925c3d94b2261ba9acb883c7d63471.svg]]
:END:


#+begin_src jupyter-python
    for model in models:
        plt.plot(model.t, abs(model.total_energy_from_power().value - model.total_energy().value))
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/c273a43c171394f3692125872ff6c55120ae3433.svg]]


#+begin_src jupyter-python
  #[model.efficiency(steady_idx=2).value * 100 for model in models][10]
  models[10].strobe, models[1].strobe
#+end_src

#+RESULTS:
| array | ((0 65 130 195)) | array | ((0 1000 2001 3001)) |
| array | ((0 35 70 105))  | array | ((0 1000 2001 3001)) |

#+begin_src jupyter-python
  models[10].system_energy().N
#+end_src

#+RESULTS:
: 80000

#+begin_src jupyter-python
  ot.plot_power_eff_convergence(models, 2)
#+end_src

#+RESULTS:
:RESULTS:
| <Figure | size | 1200x400 | with | 2 | Axes> | (<AxesSubplot: xlabel= $N$ ylabel= $P$ > <AxesSubplot: xlabel= $N$ ylabel= $\eta$ >) |
[[file:./.ob-jupyter/9153bc446bd9633e64c8e85412f9927be1726228.svg]]
:END:


#+begin_src jupyter-python
  f_power = plt.figure()
  a_power = f_power.add_subplot(1, 1, 1, projection="3d")
  f_work = plt.figure()
  a_work = f_work.add_subplot(1, 1, 1, projection="3d")
  f_efficiency = plt.figure()
  a_efficiency = f_efficiency.add_subplot(1, 1, 1, projection="3d")
  f_mean_inter_power = plt.figure()
  a_mean_inter_power = f_mean_inter_power.add_subplot(1, 1, 1, projection="3d")
  f_mean_system_power = plt.figure()
  a_mean_system_power = f_mean_system_power.add_subplot(1, 1, 1, projection="3d")

  for ax in [a_power, a_efficiency, a_work, a_mean_inter_power, a_mean_system_power]:
      ax.set_box_aspect(aspect=None, zoom=0.7)
      ax.set_xlabel(r"$\delta$")
      ax.set_ylabel(r"$\Theta$")
      ax.xaxis.labelpad = 10
      ax.view_init(elev=30.0, azim=-29, roll=0)


  ot.plot_3d_heatmap(
      models,
      lambda model: np.clip(
          np.nan_to_num(model.efficiency(steady_idx=2).value * 100), 0, np.inf
      ),
      lambda model: model.Î´[0],
      lambda model: model.Î˜,
      ax=a_efficiency,
  )
  a_efficiency.set_zlabel(r"$\eta$")

  ot.plot_3d_heatmap(
      models,
      lambda model: np.clip(-model.power(steady_idx=2).value * 1000, 0, np.inf),
      lambda model: model.Î´[0],
      lambda model: model.Î˜,
      ax=a_power,
  )
  a_power.set_zlabel(r"$\bar{P}/10^{-3}$")
  a_power.zaxis.labelpad = 8

  ot.plot_3d_heatmap(
      models,
      lambda model: np.clip(
          ot.val_relative_to_steady(model, model.interaction_power().sum_baths(), 2)[
              1
          ].mean.value
          ,* 1000,
          0,
          np.inf,
      ),
      lambda model: model.Î´[0],
      lambda model: model.Î˜,
      ax=a_mean_inter_power,
  )
  a_mean_inter_power.set_zlabel(r"$-\bar{P}_\mathrm{int}/10^{-3}$")
  a_mean_inter_power.zaxis.labelpad = 8
  a_mean_inter_power.view_init(elev=30.0, azim=110, roll=0)

  ot.plot_3d_heatmap(
      models,
      lambda model: np.clip(
          -ot.val_relative_to_steady(model, model.system_power().sum_baths(), 2)[
              1
          ].mean.value
          ,* 1000,
          0,
          np.inf,
      ),
      lambda model: model.Î´[0],
      lambda model: model.Î˜,
      ax=a_mean_system_power,
  )
  a_mean_system_power.set_zlabel(r"$\bar{P}_\mathrm{sys}/10^{-3}$")
  a_mean_system_power.zaxis.labelpad = 8

  ot.plot_3d_heatmap(
      models,
      lambda model: np.clip(-model.power(steady_idx=2).value * model.Î˜, 0, np.inf),
      lambda model: model.Î´[0],
      lambda model: model.Î˜,
      ax=a_work,
  )
  a_work.set_zlabel(r"$-W$")
  a_work.zaxis.labelpad = 8


  plt.tight_layout()

  fs.export_fig("coupling_speed_scan_power", x_scaling=1, y_scaling=1, fig=f_power)
  fs.export_fig("coupling_speed_scan_work", x_scaling=1, y_scaling=1, fig=f_work)
  fs.export_fig(
      "coupling_speed_scan_efficiency", x_scaling=1, y_scaling=1, fig=f_efficiency
  )
  fs.export_fig(
      "coupling_speed_scan_interpower", x_scaling=1, y_scaling=1, fig=f_mean_inter_power
  )
  fs.export_fig(
      "coupling_speed_scan_syspower", x_scaling=1, y_scaling=1, fig=f_mean_system_power
  )
#+end_src

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/2f0b0c42049806b930471968f418c6e09a12bb14.svg]]
[[file:./.ob-jupyter/37e8a4ed48d03590f17e8fa905d06a079ef9489d.svg]]
[[file:./.ob-jupyter/58030ee1b1a60e263a7ecff46e5e0978c0ebf080.svg]]
[[file:./.ob-jupyter/3e5f7ce49106a6dccaec67c139a3960c3b5977a3.svg]]
[[file:./.ob-jupyter/0f0039092a2d1bba7e2ee7161fd53005eea9c3d3.svg]]
:END:

#+begin_src jupyter-python
  f = plt.figure()
  a_power = f.add_subplot(121, projection="3d")
  a_efficiency = f.add_subplot(122, projection="3d")
  for ax in [a_power, a_efficiency]:
      ax.set_box_aspect(aspect=None, zoom=0.85)
      ax.set_xlabel(r"$\delta$")
      ax.set_ylabel(r"$\Theta$")

  ot.plot_3d_heatmap(
      models,
      lambda model: np.divide(np.abs(model.power(steady_idx=2).Ïƒ), np.abs(model.power(steady_idx=2).value)),
      lambda model: model.Î´[0],
      lambda model: model.Î˜,
      ax=a_power,
  )
  a_power.set_zlabel(r"$\sigma_P/|P|$")


  ot.plot_3d_heatmap(
      models,
      lambda model: np.divide(np.clip(np.nan_to_num(model.efficiency(steady_idx=2).Ïƒ * 100), 0, np.inf), np.abs(model.efficiency(steady_idx=2).value * 100)),
      lambda model: model.Î´[0],
      lambda model: model.Î˜,
      ax=a_efficiency,
  )
  a_efficiency.set_zlabel(r"$\sigma_\eta/|\eta|$")
  fs.export_fig("coupling_speed_scan_power_efficiency_uncertainty")
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/40d7d6c96595d9d2028f7c9d6b5bb9e1646e07b4.svg]]


* Weak Coupling Limit
#+begin_src jupyter-python :tangle tangle/weak_coupling_model.py
  <<boilerplate>>
  <<make-model>>
#+end_src

#+RESULTS:

#+begin_src jupyter-python :results none :tangle tangle/weak_coupling_model.py
  weak_coupling_model = make_model(50, .2)
  weak_coupling_model.num_cycles = 5
#+end_src


** Integrate
#+begin_src jupyter-python  :tangle tangle/weak_coupling_model.py
  ot.integrate_online(weak_coupling_model, 50_000, analyze_kwargs=dict(every=10_000))
#+end_src

#+RESULTS:
: [INFO    hops.core.integration     290962] Choosing the nonlinear integrator.
: [INFO    root                      290962] Starting analysis process.
: [INFO    root                      290962] Started analysis process with pid 304855.
: [INFO    hops.core.hierarchy_data  290962] Creating the streaming fifo at: /home/hiro/Documents/Projects/UNI/master/eflow_paper/python/otto_motor/subprojects/cycle_length_coupling_strength/results_f9d1bda1cf5d0f7419d0cc1b1b5db082c13604538255d3dfbc05af9f0d354f49.fifo
: [INFO    hops.core.integration     290962] Using 16 integrators.
: [INFO    hops.core.integration     290962] Some 16 trajectories have to be integrated.
: [INFO    hops.core.integration     290962] Using 1001 hierarchy states.
: 100% 16/16 [01:28<00:00,  5.52s/it]
:

** Analysis
#+begin_src jupyter-python
  ot.plot_energy(weak_coupling_model)
  weak_coupling_model.total_energy_from_power().slice(slice(weak_coupling_model.strobe[1][1], None, 1)).values
#+end_src

#+RESULTS:
:RESULTS:
| array | ((-0.18507824 -0.18507818 -0.18506804 ... -0.87570649 -0.87570633 -0.87570633)) |
[[file:./.ob-jupyter/ed60941fac1fe754ef3b56d5f56b7b83a3d91291.svg]]
:END:


#+begin_src jupyter-python

  #weak_coupling_model.strobe[1]
#+end_src

#+RESULTS:
:RESULTS:
# [goto error]
: [0;31m---------------------------------------------------------------------------[0m
: [0;31mIndexError[0m                                Traceback (most recent call last)
: Cell [0;32mIn[92], line 1[0m
: [0;32m----> 1[0m weak_coupling_model[38;5;241m.[39mtotal_power()[38;5;241m.[39mvalue[[43mweak_coupling_model[49m[38;5;241;43m.[39;49m[43mstrobe[49m[43m[[49m[38;5;241;43m1[39;49m[43m][49m[43m[[49m[38;5;241;43m7[39;49m[43m][49m:[38;5;241m-[39m[38;5;241m1[39m][38;5;241m.[39mmean()
: [1;32m      3[0m [38;5;66;03m#weak_coupling_model.strobe[1][39;00m
:
: [0;31mIndexError[0m: index 7 is out of bounds for axis 0 with size 6
:END:



#+begin_src jupyter-python
weak_coupling_model.efficiency(steady_idx=-3)
#+end_src

#+RESULTS:
: EnsembleValue([(16, 0.3649132926357113, 0.21802876349189884)])


* Things to Look At
- power and efficiency
- magnitude of interaction energies
- magnitude of interaction powers
