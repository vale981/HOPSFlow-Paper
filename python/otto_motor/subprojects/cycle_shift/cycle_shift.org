:PROPERTIES:
:ID:       c06111fd-d719-433d-a316-c163f6e1d384
:END:
#+PROPERTY: header-args :session otto_cycle_shift :kernel python :pandoc no :async yes :tangle tangle/cycle_shift.py :noweb yes

Having found a prototypical cycle, we now try to shift the timings to
find if there is an improvement.

* Boilerplate
#+name: boilerplate
#+begin_src jupyter-python :results none
  import plot_utils as pu
  from hiro_models.one_qubit_model import StocProcTolerances
  from hiro_models.otto_cycle import OttoEngine, get_energy_gap
  import hiro_models.model_auxiliary as aux
  import numpy as np
  import qutip as qt
  import utilities as ut
  import stocproc
  import matplotlib.pyplot as plt
  import otto_utilities as ot
  import shift_cycle as sc
  import ray
  import figsaver as fs
  ray.shutdown()

  #ray.init(address='auto')
  ray.init()
  from hops.util.logging_setup import logging_setup
  import logging
  logging_setup(logging.INFO)
#+end_src

* Baseline Model and Shifts
In here, we define the baseline model and shift the cycle.
Later we will experiment with some modifications to this baseline
cycle.

** Model Definition
**Note: Don't run this in Jupyter**
#+begin_src jupyter-python :tangle tangle/original.py :results none
  <<boilerplate>>
#+end_src

Now we need to lay down a grid size.
We start with one dimension and may add another later / dimension.
We shift so that we just overlap with coupling/decoupling and one above.
#+begin_src jupyter-python :tangle tangle/original.py
  shifts = sc.make_shifts(extra_r=4)
  shifts
#+end_src

#+RESULTS:
: array([-0.18, -0.12, -0.06,  0.  ,  0.06,  0.12,  0.18,  0.24,  0.3 ,
:         0.36,  0.42])

#+begin_src jupyter-python :tangle tangle/original.py
  import itertools
  models = [sc.make_model(shift, shift) for shift in shifts]
  baseline = models[3]
#+end_src

#+RESULTS:


#+begin_src jupyter-python
  ot.plot_cycle(baseline)
  fs.export_fig("cycle_prototype", y_scaling=.7)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/bf3e79728b227169611c2bb164de0c39019d4d42.svg]]

#+begin_src jupyter-python :tangle no
  #ot.plot_cycles(models, bath=0, legend=True)
  from itertools import cycle
  lines = ["--","-.",":", "-"]
  linecycler = cycle(lines)

  fig, ax = plt.subplots()
  t = np.linspace(0, models[0].Θ, 1000)
  l, = ax.plot(t, models[0].H.operator_norm(t)/2-.5, linewidth=3, color="lightgrey")
  legend_1 = ax.legend([l], [r"$(||H||-1)/2$"], loc="center left", title="Reference")
  from cycler import cycler
  for model in models:
      ax.plot(t, model.coupling_operators[1].operator_norm(t), label=fr"${model.L_shift[0] * 100:.0f}\%$", linestyle=(next(linecycler)))
  ax.legend(title=r"Shift of $L_h$", fontsize="x-small", ncols=2)
  ax.set_xlabel(r"$\tau$")
  ax.set_ylabel(r"Operator Norm")
  ax.add_artist(legend_1)
  ax.set_xlim((0, models[0].Θ))
  fs.export_fig("cycle_shift_shifts", x_scaling=2, y_scaling=.5)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/a711a4ee574e382ee7666fed225d98c35dc52d1f.svg]]

** Integrate
Here we integrate/simulate the models. This should be run on the
cluster.

Running it locally won't do any harm though.
#+begin_src jupyter-python :tangle tangle/original.py
  ot.integrate_online_multi(models, 80_000, increment=10_000, analyze_kwargs=dict(every=10_000))
#+end_src

#+RESULTS:

** Analysis
*** Baseline
This plots the full energy overview for the baseline model.
#+begin_src jupyter-python
  ot.plot_energy(baseline)
  print(
      fs.tex_value(baseline.system_energy().N,  prefix="N="),
    )

  fs.export_fig("prototype_full_energy", x_scaling=2, y_scaling=1)
#+end_src

#+RESULTS:
:RESULTS:
: \(N=80000\)
[[file:./.ob-jupyter/73e9a2cd60b362f39b0b62a47056740f562e3d08.svg]]
:END:

We would like to know how close all of this comes to the thermal states.
#+begin_src jupyter-python
 def thermal_state(T, Ω):
     ρ = np.array([[np.exp(-Ω/T), 0], [0, 1]])
     ρ /= np.sum(np.diag(ρ))

     return ρ
 import hops.util.utilities
 from hopsflow.util import EnsembleValue
 for model in [baseline]:
     with aux.get_data(model) as data:
         trace_dist_c = hops.util.utilities.trace_distance(data, relative_to=thermal_state(model.T[0], model.energy_gaps[0]))
         trace_dist_h = hops.util.utilities.trace_distance(data, relative_to=thermal_state(model.T[1], model.energy_gaps[1]))
         f, (a, aa) = plt.subplots(nrows=1, ncols=2)
         print(thermal_state(model.T[0], model.energy_gaps[0]))
         print(thermal_state(model.T[1], model.energy_gaps[1]))
         pu.plot_with_σ(model.t, EnsembleValue(trace_dist_c), ax=a, label=r"$||\rho(\tau)-\rho_c||$")
         pu.plot_with_σ(model.t, EnsembleValue(trace_dist_h), ax=a, label=r"$||\rho(\tau)-\rho_h||$")
         aa.plot(model.t, data.rho_t_accum.mean[:,0,0].real,  label=r"$\rho_{00}$")
         aa.axhline(thermal_state(model.T[1], model.energy_gaps[1])[0,0],  label=r"$\rho_{h,00}$", color="lightgray")
         aa.axhline(thermal_state(model.T[0], model.energy_gaps[0])[0,0],  label=r"$\rho_{c,00}$", color="lightgray")


         a.set_xlim(2*model.Θ, 3*model.Θ)
         aa.set_xlim(2*model.Θ, 3*model.Θ)
         a.plot(model.t, (model.H(model.t)[:, 0, 0] - 1)/2, label="$H_\mathrm{sys}$ Modulation")
         a.set_xlabel(r"$\tau$")
         aa.set_xlabel(r"$\tau$")
         #a.set_xlim(155)
         a.legend()
         aa.legend()
         aa.set_ylim((0.1,.4))
         fs.export_fig("prototype_thermalization", y_scaling=.7, x_scaling=2)
#+end_src

#+RESULTS:
#+begin_example
  [[0.11920292 0.        ]
   [0.         0.88079708]]
  [[0.37754067 0.        ]
   [0.         0.62245933]]
  /nix/store/fai1b55231rnk4jyj0kjicdnqcgdf9ph-python3-3.9.15-env/lib/python3.9/site-packages/matplotlib/cbook/__init__.py:1369: ComplexWarning: Casting complex values to real discards the imaginary part
    return np.asarray(x, float)
  /nix/store/fai1b55231rnk4jyj0kjicdnqcgdf9ph-python3-3.9.15-env/lib/python3.9/site-packages/matplotlib/axes/_axes.py:5340: ComplexWarning: Casting complex values to real discards the imaginary part
    pts[0] = start
  /nix/store/fai1b55231rnk4jyj0kjicdnqcgdf9ph-python3-3.9.15-env/lib/python3.9/site-packages/matplotlib/axes/_axes.py:5341: ComplexWarning: Casting complex values to real discards the imaginary part
    pts[N + 1] = end
  /nix/store/fai1b55231rnk4jyj0kjicdnqcgdf9ph-python3-3.9.15-env/lib/python3.9/site-packages/matplotlib/axes/_axes.py:5344: ComplexWarning: Casting complex values to real discards the imaginary part
    pts[1:N+1, 1] = dep1slice
  /nix/store/fai1b55231rnk4jyj0kjicdnqcgdf9ph-python3-3.9.15-env/lib/python3.9/site-packages/matplotlib/axes/_axes.py:5346: ComplexWarning: Casting complex values to real discards the imaginary part
    pts[N+2:, 1] = dep2slice[::-1]
#+end_example

Plotting the pauli matrix expectation values, we can see that the
dynamics only take place on the z-axis. This is addressed in [[id:9d7a11f2-f479-4e95-8775-31050bcc4fb7][Off-Axis Hamiltonian]]
#+begin_src jupyter-python
 ot.plot_bloch_components(baseline)
 fs.export_fig("state_evolution", y_scaling=.7)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/a645250e5f7a8890257674fe5de32b09d9de78f1.svg]]

Let us plot an overview of the work done by system and interaction
modulation over a cycle for the baseline model.
#+begin_src jupyter-python
 ot.plot_steady_energy_changes([baseline], 2, label_fn=lambda _: "")
 fs.export_fig("prototype_energy_change", y_scaling=.7)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/888e4e87b2f952b2d1866055b087a2d0bfe38ed0.svg]]

*** pV Diagrams
Let's attempt to draw the p_v diagrams :).

#+begin_src jupyter-python :tangle scripts/plot_pv_diags.py
  from matplotlib import collections as mc
  from matplotlib.colors import colorConverter
  from collections import deque
  from itertools import islice
  import pickle
  import matplotlib.pyplot as plt
  import numpy as np


  def sliding_window(iterable, n):
      """
      sliding_window('ABCDEFG', 4) -> ABCD BCDE CDEF DEFG

      recipe from python docs
      """
      it = iter(iterable)
      window = deque(islice(it, n), maxlen=n)
      if len(window) == n:
          yield tuple(window)
      for x in it:
          window.append(x)
          yield tuple(window)


  def color_gradient(x, y, c1, c2, **kwargs):
      """
      Creates a line collection with a gradient from colors c1 to c2,
      from data x and y.
      """
      n = len(x)
      if len(y) != n:
          raise ValueError("x and y data lengths differ")
      return mc.LineCollection(
          sliding_window(zip(x, y), 2),
          colors=np.linspace(colorConverter.to_rgb(c1), colorConverter.to_rgb(c2), n - 1),
          ,**kwargs,
      )


  def assemble_segments(data, segments):
      final = []

      for begin, end in zip(segments, segments[1:]):
          if begin > end:
              final.append(np.concatenate([data[begin:-1], data[:end]]))
          else:
              final.append(data[begin:end])

      return np.concatenate(final)


  def plot_modulation_interaction_diagram(all_value, all_modulation, phase_indices):
      fig, ax = plt.subplots()

      closed =  abs(all_value[phase_indices[0]]- all_value[phase_indices[-1]])< 1e-3
      if not closed:
          phase_indices = np.concatenate([phase_indices, [phase_indices[0]]])

      ax.plot(all_modulation, all_value, linewidth=3, color="cornflowerblue")

      modulation = assemble_segments(all_modulation, phase_indices)
      value = assemble_segments(all_value, phase_indices)

      ax.add_collection(
          color_gradient(modulation, value, "cornflowerblue", "red", linewidth=3)
      )

      phase_indices = phase_indices[:-1]
      last = np.array([np.nan, np.nan])
      
      for i, index in enumerate(phase_indices):
          ax.scatter(
              all_modulation[index], all_value[index], zorder=100, marker=".", s=200, color="black"
          )
          
          next = np.array((all_modulation[index], all_value[index]))
          
          ax.annotate(
              str(i + 1),
              xy=next,
              xytext=(5, 5)  if (np.linalg.norm(next- last)) > 1e-2 else (5, -10),
              xycoords="data",
              textcoords="offset points",
          )

          last = next

      x0,x1 = ax.get_xlim()
      y0,y1 = ax.get_ylim()
      ax.set_aspect(abs(x1-x0)/abs(y1-y0))

      return fig, ax


  def plot_diagrams(name):
      with open(f"data/pv_{name}.pickle", "rb") as file:
          diagram_data = pickle.load(file)

      for data in diagram_data:
          fig, ax = plot_modulation_interaction_diagram(*data["args"])
          ax.set_xlabel(data["xlabel"])
          ax.set_ylabel(data["ylabel"])

          plt.savefig(f"figures/{name}_{data['name']}")
#+end_src

#+RESULTS:


#+begin_src jupyter-python
  import pickle

  def save_data(model, name):
      data = [
          {
              "name": f"bath_modulation_interaction_{bath_name}",
              "xlabel": rf"$||L_{bath_name}(t)||$",
              "ylabel": r"$\langle{H_\mathrm{I}}\rangle$",
              "args": ot.get_modulation_and_value(
                  model,
                  model.coupling_operators[bath],
                  model.interaction_energy().for_bath(bath),
              ),
          }
          for bath, bath_name in zip([0, 1], ["c", "h"])
      ]  + [
          {
              "name": f"system_modulation_system_energy",
              "xlabel": r"$||H_\mathrm{S}||$",
              "ylabel": r"$\langle{H_\mathrm{S}}\rangle$",
              "args": ot.get_modulation_and_value(
                  model,
                  model.H,
                  model.system_energy(),
                  steady_idx=2
              ),
          }
      ]

      with open(f"data/pv_{name}.pickle", "wb") as file:
          pickle.dump(data, file)





  # vals = ot.get_modulation_and_value(model, model.coupling_operators[0], model.interaction_energy().for_bath(0))
  # plot_modulation_interaction_diagram(*vals)
#+end_src

#+RESULTS:

#+begin_src jupyter-python
  save_data(baseline, "baseline")
#+end_src

#+RESULTS:


#+begin_src jupyter-python :tangle scripts/plot_pv_diags.py
  plot_diagrams("baseline")
#+end_src

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/6b9fa7fa55f61230b07cbd6a233633bf7f257faa.svg]]
[[file:./.ob-jupyter/0a766092ad2861998ba8a922784b6e6497c72124.svg]]
[[file:./.ob-jupyter/b5f8cf75b1c0888d4ab8a2c1fb9987e8f3807c41.svg]]
:END:





*** Shifted Models
Let us print the power output (relative to the baseline = unshifted model) and efficiency.
#+begin_src jupyter-python
 for model in models:
   print(model.power(steady_idx=2).value / baseline.power(steady_idx=2).value, model.efficiency(steady_idx=2).value)
#+end_src

#+RESULTS:
#+begin_example
  -2.77597511693978 -2.4772877227717958
  -2.0434846540636498 -1.6243768550730728
  0.5710213861808199 0.19310160522534914
  1.0 0.3002164459369506
  1.1580729241081245 0.3201551362641393
  1.621073860181052 0.32914493962691976
  1.676329717306901 0.3155858623648209
  1.6056907132267833 0.29627949690062266
  1.4297898620293028 0.264279816138587
  0.7161356715968495 0.13903993767016806
  -1.2535087048383218 -0.29154092061712156
#+end_example


This plots the power output and efficiency as a function of sample
size to check convergence.
#+begin_src jupyter-python
 ot.plot_power_eff_convergence(models)
 fs.export_fig("cycle_shift_convergence", x_scaling=2, y_scaling=.7)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/8d9b7d2fcd5ef897070660fa264fd9e904a916ea.svg]]

We see that we get a pretty good picture after about 30k-40k samples.

This is an overview over powers and the efficiency.
#+begin_src jupyter-python
 ot.plot_powers_and_efficiencies(np.array(shifts) * 100, models, xlabel="Cycle Shift")
 fs.export_fig("cycle_shift_power_efficiency", y_scaling=.7, x_scaling=1)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/95ce996f5adf865114a7efc488992da2993495a8.svg]]

The best shift:
#+begin_src jupyter-python
 best_shift = shifts[np.argmax([-model.power(steady_idx=2).value for model in models])]
 best_shift_model = sc.make_model(best_shift, best_shift)
 best_shift
#+end_src

#+RESULTS:
: 0.18

This contrasts the system/interaction power output for the baseline
and the best shift model.
#+begin_src jupyter-python
 fig, ax =ot.plot_steady_energy_changes([baseline, best_shift_model], 2, label_fn=lambda m: ("baseline" if m.hexhash == baseline.hexhash else "shifted"))
 ax.legend(loc="lower left")
 fs.export_fig("shift_energy_change", y_scaling=.7)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/1b65cbe8a112cceb40aa0440d33ed40dca30dcf1.svg]]


Let us plot the interaction power in the steady state for baseline and
best-shift. We have to shift the time to make them overlap correctly.
#+begin_src jupyter-python
 t_shift_begin = (2 - best_shift) * baseline.Θ
 t_begin = 2 * baseline.Θ
 t_shift_end = (3 - best_shift) * baseline.Θ
 final_period_idx = np.argmin(abs(baseline.t - t_begin))
 final_period_shifted = np.argmin(abs(baseline.t - t_shift_begin))
 final_period_shifted_end = final_period_shifted - final_period_idx

 t_baseline = baseline.t[final_period_shifted:final_period_shifted_end]
 t_final_period = baseline.t[final_period_idx:]
 t_plot = baseline.t[: len(t_baseline)]
 interaction_change_baseline_cold = (
     baseline.interaction_power()
     .for_bath(0)
     .slice(slice(final_period_shifted, final_period_shifted_end))
     .value
 )
 interaction_change_best_cold = (
     best_shift_model.interaction_power()
     .for_bath(0)
     .slice(slice(final_period_idx, len(baseline.t)))
     .value
 )
 interaction_change_baseline_hot = (
     baseline.interaction_power()
     .for_bath(1)
     .slice(slice(final_period_shifted, final_period_shifted_end))
     .value
 )
 interaction_change_best_hot = (
     best_shift_model.interaction_power()
     .for_bath(1)
     .slice(slice(final_period_idx, len(baseline.t)))
     .value
 )


 fig, ax = plt.subplots()
 ax.plot(t_plot, interaction_change_baseline_cold, label="baseline")
 ax.plot(t_plot, interaction_change_best_cold, label="shifted")
 ax.plot(t_plot, interaction_change_baseline_hot, linestyle="--", color="C0")
 ax.plot(t_plot, interaction_change_best_hot, linestyle="--", color="C1")
 ax.legend()
 ax.set_xlabel(r"$\tau$")
 ax.set_ylabel(r"$P_{\mathrm{int}}$")
 fs.export_fig("shift_power", y_scaling=0.7)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/ebdd9c91ce756ae30681a68a43f439514a96bf8d.svg]]


Let us zoom in on the cold bath decoupling process to understnad this better.
#+begin_src jupyter-python
  f, a = plt.subplots()
  a.axhline(best_shift_model.system_energy().value[np.argmin(abs(best_shift_model.t - model.Θ * 2))], color="gray", linestyle="--")
  r = pu.plot_with_σ(
      best_shift_model.t, best_shift_model.interaction_energy().sum_baths(), ax=a,
      label=r"$\langle H_\mathrm{inter}\rangle$"
  )
  pu.plot_with_σ(
      best_shift_model.t, best_shift_model.system_energy(), ax=a, label=r"$\langle H_\mathrm{sys}\rangle$"
  )
  # a.plot(best_shift_model.t, best_shift_model.H(best_shift_model.t)[:, 0,0])
  a.plot(
      best_shift_model.t,
      best_shift_model.coupling_operators[0].operator_norm(best_shift_model.t) / 5,
      label="cold bath modulation",
  )


  a.plot(
      best_shift_model.t, best_shift_model.system.operator_norm(best_shift_model.t) / 5,
      label="system modulation"
  )

  a.plot(
      best_shift_model.t,
      best_shift_model.coupling_operators[1].operator_norm(best_shift_model.t) / 5,
      label="hot bath modulation",
  )
  # a.plot(best_shift_model.t, best_shift_model.coupling_operators[1].operator_norm(best_shift_model.t) / 5)
  a.set_xlim((model.Θ * 2, model.Θ * 2 + 20))

  a.set_ylim((-.21, .45))
  a.set_xlabel(r"$\tau$")
  a.legend(loc="upper right", fontsize="x-small")
  fs.export_fig("cold_bath_decoupling", y_scaling=.6)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/15e1e2b441e6a10d9b69f585ff691d7e54d0320d.svg]]

How does this look like for the baseline?
#+begin_src jupyter-python
  f, a = plt.subplots()
  a.axhline(baseline.system_energy().value[np.argmin(abs(baseline.t - model.Θ * 2))], color="gray", linestyle="--")
  r = pu.plot_with_σ(
      baseline.t, baseline.interaction_energy().sum_baths(), ax=a,
      label=r"$\langle H_\mathrm{inter}\rangle$"
  )
  pu.plot_with_σ(
      baseline.t, baseline.system_energy(), ax=a, label=r"$\langle H_\mathrm{sys}\rangle$"
  )
  # a.plot(baseline.t, baseline.H(baseline.t)[:, 0,0])
  a.plot(
      baseline.t,
      baseline.coupling_operators[0].operator_norm(baseline.t) / 5,
      label="cold bath modulation",
  )

  a.plot(
        baseline.t, baseline.system.operator_norm(baseline.t) / 5,
        label="system modulation"
    )
  a.plot(
      baseline.t,
      baseline.coupling_operators[1].operator_norm(baseline.t) / 5,
      label="hot bath modulation",
  )

  # a.plot(baseline.t, baseline.coupling_operators[1].operator_norm(baseline.t) / 5)
  a.set_xlim((model.Θ * 2-5, model.Θ * 2 + 13))

  a.set_ylim((-.21, .45))
  a.set_xlabel(r"$\tau$")
  a.legend(loc="upper right", fontsize="x-small")
  #fs.export_fig("cold_bath_decoupling", y_scaling=.6)
  fs.export_fig("cold_bath_decoupling_baseline", y_scaling=.6)

#+end_src

#+RESULTS:
[[file:./.ob-jupyter/392899a8a7f82eda25a92fad0cf029862311594f.svg]]


* Slower switching
Let us explore what happens when modulate the coupling a bit slower
switch slower.

** Model Construction
#+begin_src jupyter-python :tangle tangle/long.py
 <<boilerplate>>
#+end_src

#+RESULTS:

#+begin_src jupyter-python :tangle tangle/long.py
 shifts = sc.make_shifts(extra_r=4)

 long_models = [sc.make_model(shift, shift, switch_t=6.) for shift in shifts]
 long_baseline = sc.make_model(0., 0., switch_t=6.)
#+end_src

#+RESULTS:

#+begin_src jupyter-python :tangle no
 fig, ax = plt.subplots()
 t = np.linspace(0, models[0].Θ, 1000)
 ax.plot(t, models[3].coupling_operators[0].operator_norm(t), color="C1", linewidth=1, label="Fast Switching")
 ax.plot(t, models[3].coupling_operators[1].operator_norm(t), color="C1", linestyle="--", linewidth=1)
 ax.plot(t, long_models[3].coupling_operators[0].operator_norm(t), color="C2", linewidth=1, label="Slow Switching")
 ax.plot(t, long_models[3].coupling_operators[1].operator_norm(t), color="C2", linestyle="--", linewidth=1)

 ax.set_xlabel(r"$\tau$")
 ax.set_ylabel(r"$||L_{h/c}||$")
 ax.legend()
 #fs.export_fig("cycle_shift_shift_vs_overlap", y_scaling=.6)
 #ot.plot_cycles(all_overlap_models[0:2], legend=True)
#+end_src

#+RESULTS:
:RESULTS:
: <matplotlib.legend.Legend at 0x7f24dc503550>
[[file:./.ob-jupyter/33dae463427019962039419fbf34de0e92f69a32.svg]]
:END:



** Integration
#+begin_src jupyter-python :tangle tangle/long.py
 ot.integrate_online_multi(long_models, 80_000, increment=10_000, analyze_kwargs=dict(every=10_000))
#+end_src

#+RESULTS:
** Anaylysis
Let us look at power and efficiency.
#+begin_src jupyter-python
 for shift, model in zip(shifts, long_models):
     print(
         shift, best_shift,
         model.power(steady_idx=2).N,
         model.power(steady_idx=2).value / long_baseline.power(steady_idx=2).value,
         (model.efficiency(steady_idx=2).value - long_baseline.efficiency(steady_idx=2).value) * 100,
         (model.efficiency(steady_idx=2).value, long_baseline.efficiency(steady_idx=2).value),
     )
#+end_src

#+RESULTS:
#+begin_example
  -0.18 0.18 80000 -0.7534604455561659 -108.77944601456684 (-0.6547883379568094, 0.4330061221888589)
  -0.12 0.18 80000 0.5591648896822077 -14.974955411404467 (0.28325656807481425, 0.4330061221888589)
  -0.06 0.18 80000 0.9985149794296736 0.0037407432686098474 (0.433043529621545, 0.4330061221888589)
  0.0 0.18 80000 1.0 0.0 (0.4330061221888589, 0.4330061221888589)
  0.06 0.18 80000 0.991206944683175 0.23007686496274715 (0.4353068908384864, 0.4330061221888589)
  0.12 0.18 80000 1.1339755806282883 0.3265587668820624 (0.43627170985767955, 0.4330061221888589)
  0.18 0.18 80000 1.297675283650504 -2.9821368425732797 (0.4031847537631261, 0.4330061221888589)
  0.24 0.18 80000 1.2031272812376834 -7.638926235390614 (0.3566168598349528, 0.4330061221888589)
  0.3 0.18 80000 0.7381994151953918 -20.86521478070438 (0.22435397438181512, 0.4330061221888589)
  0.36 0.18 80000 -0.45819153140116126 -60.284418918547836 (-0.16983806699661946, 0.4330061221888589)
  0.42 0.18 80000 -1.4846084056353754 -118.88415735590576 (-0.7558354513701987, 0.4330061221888589)
#+end_example

Here, we contrast the slow/fast coupling modulation protocols.
#+begin_src jupyter-python
 fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2)
 _, ax1_right = ot.plot_powers_and_efficiencies(np.array(shifts) * 100, models, xlabel="Cycle Shift", ax=ax1)[2]
 _, ax2_right = ot.plot_powers_and_efficiencies(np.array(shifts) * 100, long_models, xlabel="Cycle Shift", ax=ax2)[2]

 ax1_right.sharey(ax2_right)
 ax1.sharey(ax2)

 ax1.set_title("Fast Coupling")
 ax2.set_title("Slow Coupling")
 fs.export_fig("cycle_shift_power_efficiency_with_slower", y_scaling=.7, x_scaling=2)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/2da75cadbb1995855015de60aeb90c920565d142.svg]]

Aho! The trick is just to slow down the coupling switching.

I know, horrible code. I just wan't to finish this...
#+begin_src jupyter-python
 best_long_idx = np.argmax([-model.power(steady_idx=2).value for model in long_models])
 best_long_shift = shifts[best_long_idx]
 best_long_shift_model = long_models[best_long_idx]
 best_long_shift
#+end_src

#+RESULTS:
: 0.18


Let's contrast the energy change dynamics in slow vs fast modulation
#+begin_src jupyter-python
 fig, ax =ot.plot_steady_energy_changes([best_long_shift_model, best_shift_model], 2, label_fn=lambda m: ("long" if m.hexhash == best_long_shift_model.hexhash else "short"))
 ax.legend(loc="lower left")

 fs.export_fig("long_short_energy_change", y_scaling=.7)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/5418d985119098ea7dd34a612cee7193d550431c.svg]]

Now let's try to find out why the efficiency improved.

#+begin_src jupyter-python
 best_long_model = long_models[5]

 flow_long = -1*best_long_model.bath_energy_flow().for_bath(0)
 power_long = best_long_model.interaction_power().for_bath(0)

 flow_short = -1*best_shift_model.bath_energy_flow().for_bath(0)
 power_short = best_shift_model.interaction_power().for_bath(0)

 plt.plot(best_shift_model.t, flow_short.value, label="fast coupling")
 plt.plot(best_shift_model.t, flow_long.value, label="slow coupling")
 plt.plot(best_shift_model.t, power_short.value, linestyle="--", color="C0")
 plt.plot(best_shift_model.t, power_long.value, linestyle="--",  color="C1")
 plt.xlim((2*best_long_model.Θ-5, 2*best_long_model.Θ+12))
 plt.ylim((-.015,.06))
 plt.legend()
 plt.xlabel(r"$\tau$")
 fs.export_fig("cold_bath_flow", y_scaling=.7)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/9cecea40e225eaae34f9003fdf7e004ea0463e84.svg]]
Way less energy is dumped into the cold bath.
#+begin_src jupyter-python
 t, rel_short_cold = ot.val_relative_to_steady(
     best_shift_model,
     best_shift_model.bath_energy().for_bath(0),
     2,
     1-best_shift_model.L_shift[0]
 )

 t, rel_short_hot = ot.val_relative_to_steady(
     best_shift_model,
     best_shift_model.bath_energy().for_bath(1),
     2,
     1-best_shift_model.L_shift[0]
 )

 t, rel_long_cold = ot.val_relative_to_steady(
     best_long_model,
     best_long_model.bath_energy().for_bath(0),
     2,
     (1-best_long_model.L_shift[0])
 )
 t, rel_long_hot = ot.val_relative_to_steady(
     best_long_model,
     best_long_model.bath_energy().for_bath(1),
     2,
     (1-best_long_model.L_shift[0])
 )
 # plt.plot(t, -(rel_long_cold).value, label="slow coupling")
 # plt.plot(t, -(rel_long_hot).value, label="slow coupling")
 # plt.plot(t, best_long_model.coupling_operators[1].operator_norm(t), label="slow coupling")

 plt.plot(t, -(rel_long_cold/rel_long_hot).value, label="slow coupling")
 plt.plot(t, -(rel_short_cold/rel_short_hot).value, label="fast coupling")
 plt.plot(t, best_long_model.coupling_operators[0].operator_norm(t), color="C0", linestyle="dashed")
 plt.plot(t, best_shift_model.coupling_operators[0].operator_norm(t), color="C1", linestyle="dashed")

 plt.ylim((-.1,.75))
 plt.xlim((100, 128))
 plt.legend()
 plt.xlabel(r"$\tau$")
 plt.ylabel(r"$-\Delta \langle{H_{\mathrm{B},c}}\rangle/\Delta \langle{H_{\mathrm{B},h}}\rangle$")
 fs.export_fig("hot_vs_cold_bath", y_scaling=.7)
#+end_src

#+RESULTS:
:RESULTS:
: /home/hiro/src/hopsflow/hopsflow/util.py:331: RuntimeWarning: divide by zero encountered in divide
:   left_i[1] / right_i[1],
: /home/hiro/src/hopsflow/hopsflow/util.py:331: RuntimeWarning: invalid value encountered in divide
:   left_i[1] / right_i[1],
: /home/hiro/src/hopsflow/hopsflow/util.py:333: RuntimeWarning: divide by zero encountered in divide
:   (left_i[2] / right_i[1]) ** 2
: /home/hiro/src/hopsflow/hopsflow/util.py:334: RuntimeWarning: divide by zero encountered in divide
:   + (left_i[1] / (right_i[1]) ** 2 * right_i[2]) ** 2
: /home/hiro/src/hopsflow/hopsflow/util.py:334: RuntimeWarning: invalid value encountered in divide
:   + (left_i[1] / (right_i[1]) ** 2 * right_i[2]) ** 2
[[file:./.ob-jupyter/8cc13fa6fb6a9a90c4d74df045df24daeb3632cb.svg]]
:END:

* Slower switching + Only Cold Bath Coupling Shifted
Let's see what happens if we only shift the coupling to the cold bath.
The last section gave me the hunch, that only this shift matters.

*** Model def and intergration
#+begin_src jupyter-python :tangle tangle/only_cold.py :results none
 <<boilerplate>>
#+end_src


#+begin_src jupyter-python :results none :tangle tangle/only_cold.py
 shifts = sc.make_shifts(extra_r=4)
 cold_models = [sc.make_model(shift, shift, switch_t=6., only_cold=True) for shift in shifts]
#+end_src

#+begin_src jupyter-python :tangle tangle/only_cold.py
 #ot.integrate_online_multi(cold_models, 1, increment=1, analyze_kwargs=dict(every=10_000))
#+end_src

#+RESULTS:

#+begin_src jupyter-julia
 #aux.import_results(other_data_path="taurus/.data", other_results_path="taurus/results", models_to_import=cold_models)
#+end_src

#+RESULTS:

*** Cycle showcase
#+begin_src jupyter-python :tangle no
 fig, ax = plt.subplots()
 t = np.linspace(0, cold_models[0].Θ, 1000)
 ax.plot(t, long_models[-3].coupling_operators[0].operator_norm(t), color="C1", linewidth=1, label="both shifted")
 ax.plot(t, long_models[-3].coupling_operators[1].operator_norm(t), color="C1", linestyle="--", linewidth=1)
 ax.plot(t, cold_models[-3].coupling_operators[0].operator_norm(t), color="C2", linewidth=1, linestyle="dotted", label="only cold shifted")
 ax.plot(t, cold_models[-3].coupling_operators[1].operator_norm(t), color="C2", linestyle="--", linewidth=1)
 ax.plot(t, (cold_models[-3].system.operator_norm(t)-1)/2, color="lightgrey", linestyle="--", linewidth=1)

 ax.set_xlabel(r"$\tau$")
 ax.set_ylabel(r"$||L_{h/c}||$")
 ax.legend()
 fs.export_fig("cycle_shift_cold_shift", y_scaling=.6)
 #ot.plot_cycles(all_overlap_models[0:2], legend=True)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/19a348fee767b34e589077f332bc113e9efef74c.svg]]


#+begin_src jupyter-python
 from itertools import cycle
 lines = ["--","-.",":", "-"]
 linecycler = cycle(lines)
 fig, ax = plt.subplots()
 t = np.linspace(0, models[0].Θ, 1000)
 #l, = ax.plot(t, models[0].H.operator_norm(t)/2-.5, linewidth=3, color="lightgrey")
 l, = ax.plot(t, cold_models[3].coupling_operators[1].operator_norm(t), linewidth=3, color="lightgrey")
 legend_1 = ax.legend([l], [r"$(||H||-1)/2$"], loc="center left", title="Reference")
 from cycler import cycler
 for model in cold_models:
     ax.plot(t, model.coupling_operators[0].operator_norm(t), label=fr"${model.L_shift[0] * 100:.0f}\%$", linestyle=(next(linecycler)))
 ax.legend(title=r"Shift of $L_h$", fontsize="x-small", ncols=2)
 ax.set_xlabel(r"$\tau$")
 ax.set_ylabel(r"Operator Norm")
 ax.add_artist(legend_1)
 ax.set_xlim((0, models[0].Θ))
#+end_src

#+RESULTS:
:RESULTS:
| 0.0 | 60.0 |
[[file:./.ob-jupyter/d36dfec555f80de19d19f897d2126c0085360846.svg]]
:END:

*** Analysis
Let's contrast all three protocols.
#+begin_src jupyter-python
 fig, (ax2, ax1, ax3) = plt.subplots(nrows=1, ncols=3)
 _, ax1_right = ot.plot_powers_and_efficiencies(np.array(shifts) * 100, cold_models, xlabel="Cycle Shift", ax=ax1)[2]
 _, ax2_right = ot.plot_powers_and_efficiencies(np.array(shifts) * 100, long_models, xlabel="Cycle Shift", ax=ax2)[2]
 _, ax3_right = ot.plot_powers_and_efficiencies(np.array(shifts) * 100, models, xlabel="Cycle Shift", ax=ax3)[2]

 ax1_right.sharey(ax2_right)
 ax1.sharey(ax2)

 ax3_right.sharey(ax1_right)
 ax3.sharey(ax1)

 ax1.set_title("Cold Shifted")
 ax2.set_title("Both Shifted")
 ax3.set_title("Fast Modulation")
 fs.export_fig("cycle_shift_power_efficiency_longer_vs_only_cold", y_scaling=.7, x_scaling=2.5)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/bdb51a4a3f8c24984da621312c2898b079ee8d55.svg]]

And do it again, but in a more convenient format.
#+begin_src jupyter-python
 ot.plot_multi_powers_and_efficiencies(shifts, [models, long_models, cold_models], ["shifted", "shifted + slower modulation", "slower + only cold shifted"], xlabel=r"Shift $\delta$")
 fs.export_fig("shift_comparison", y_scaling=1, x_scaling=2)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/31768eb7041b22ce745ca08564de4479c81b662b.svg]]
#+begin_src jupyter-python
  best_cold_shift = shifts[np.argmax([-model.power(steady_idx=2).value for model in cold_models])]
  best_cold_model = sc.make_model(best_cold_shift, best_cold_shift, switch_t=6., only_cold=True)
  best_cold_shift
#+end_src

#+RESULTS:
: 0.18

**** pV Diagrams
Let's attempt to draw the p_v diagrams :).

#+begin_src jupyter-python
plt.plot(best_cold_model.t, best_cold_model.coupling_operators[0].operator_norm(best_cold_model.t))
plt.plot(best_cold_model.t, best_cold_model.H.operator_norm(best_cold_model.t))
#+end_src

#+RESULTS:
:RESULTS:
| <matplotlib.lines.Line2D | at | 0x7f24d9cb6370> |
[[file:./.ob-jupyter/85b4e10a2cbe7c5dd912e90d64e1fba3df180eb7.svg]]
:END:

#+begin_src jupyter-python
  save_data(best_cold_model, "slow_shifted")
#+end_src

#+RESULTS:

#+begin_src jupyter-python :tangle scripts/plot_pv_diags.py
  plot_diagrams("slow_shifted")
#+end_src

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/b620cfd344faa2a1218d7122c8a562a9b1f96727.svg]]
[[file:./.ob-jupyter/850f6dff33004c81c94cfbba5f6abd3f84ea313b.svg]]
[[file:./.ob-jupyter/7c3c251e45ff17415aec6561235ea57b80bbe07b.svg]]
:END:


#+begin_src jupyter-python
  ot.plot_modulation_interaction_diagram(best_cold_model, 2, 0)
  fs.export_fig("best_model_interaction_vs_modulation_cold", x_scaling=1, y_scaling=1)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/fc76cd1eb3fb9be9361876a8d165846c7ceeeb50.svg]]


#+begin_src jupyter-python
  ot.plot_modulation_interaction_diagram(best_cold_model, 2, 1)
  fs.export_fig("best_model_interaction_vs_modulation_hot", x_scaling=1, y_scaling=1)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/96c12868425649b4c7d4bcb6a01397bb21700596.svg]]

#+begin_src jupyter-python
  ot.plot_modulation_system_diagram(best_cold_model, 2)
  fs.export_fig("best_model_system_vs_modulation", x_scaling=1, y_scaling=1)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/6263be35ebb899e9c8ca2cc66662efc5f175c9d0.svg]]




* Findings
- coupling overlap doesn't help much
- with these parameters the earlier obeservation does not recur
- more scan needed
- maybe slower coupling/decoupling will help

* Off-Axis Hamiltonian
:PROPERTIES:
:ID:       9d7a11f2-f479-4e95-8775-31050bcc4fb7
:END:
Let us brieofly demonstrate the effects of rotating the system
hamiltonian.

** Construction
#+begin_src jupyter-python :tangle tangle/off_axis.py :results none
 <<boilerplate>>
#+end_src

#+begin_src jupyter-python :tangle tangle/off_axis.py
 off_ax_models = []
 weights = [.3, .6]
 param_iter = lambda: itertools.product([3, 6], weights)
 for switch_t, weight in param_iter():
     off_ax = sc.make_model(0, 0, switch_t=switch_t)
     off_ax.H_0  = 1 / 2 * (qt.sigmaz().full() + np.eye(2) + weight * qt.sigmax().full())
     # NOTE: the hamiltonians will be normalzed so that their smallest EV is 0 and the largest one is 1

     off_ax.H_1  = off_ax.H_0.copy()

     off_ax_models.append(off_ax)
#+end_src

#+RESULTS:

** Integration
#+begin_src jupyter-python :tangle tangle/off_axis.py
 ot.integrate_online_multi(off_ax_models, 10, increment=10, analyze_kwargs=dict(every=10_000))
#+end_src

#+begin_src jupyter-python
 aux.import_results(other_data_path="taurus/.data_oa", other_results_path="taurus/results")
#+end_src

** Analysis
Let's plot the pauli expectation values.
#+begin_src jupyter-python
 for (i, model), weight in zip(enumerate(off_ax_models), weights):
     f, a = ot.plot_bloch_components(model)
     #ot.plot_bloch_components(off_ax_models[i+2], ax=a, linestyle="--", label=None)

     a.set_title(rf"$r_y={weight}$")
     fs.export_fig(f"bloch_expectation_offaxis_{weight}", y_scaling=.7)
#+end_src

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/216aad96418805e8cbb925e939bb261bdb09c332.svg]]
[[file:./.ob-jupyter/ed2cd60a871ccc8b23781492e0b98084bae04018.svg]]
:END:

#+begin_src jupyter-python
 np.array(weights) / np.sqrt(1 + np.array(weights) ** 2)
#+end_src

#+RESULTS:
: array([0.28734789, 0.51449576])


#+begin_src jupyter-python
 baselines = [baseline] * 2 + [long_baseline] * 2
 for model, ref in zip(off_ax_models, baselines):
     print(model.power(steady_idx=2).value / ref.power(steady_idx=2).value, model.efficiency(steady_idx=2).value / ref.efficiency(steady_idx=2).value)
#+end_src

#+RESULTS:
: 1.0868612980640593 1.0437773131214951
: 1.1468800706147944 0.9438835472008851
: 1.070328051487702 0.9917819857660193
: 1.1178966202334308 0.958371868191535

Interestingly, even with the too-fast switching we have greater power, and greater efficiency.

#+begin_src jupyter-python
 for (i, model), weight in zip(enumerate(off_ax_models), weights):
     f, a = ot.plot_energy(model)
     a.set_title(rf"$r_y={weight}$")
     fs.export_fig(f"full_energy_offaxis_{weight}", x_scaling=2, y_scaling=1)
#+end_src

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/48801c84dacb82ca9d37f0af0519727e298ec1fd.svg]]
[[file:./.ob-jupyter/0ef615f736de27bf2129d27452b3f55fb30ff82e.svg]]
:END:
#+begin_src jupyter-python
 fig, axs = plt.subplots(ncols=2)
 (ax_full, ax) = axs

 for ax in axs:
     ax.set_xlabel(r"$\tau$")
     ax.set_ylabel(r"$\Delta X$")

 for (i, model) in enumerate([off_ax_models[0], baseline]):
     for j, (val, label) in enumerate(zip([
         model.total_energy_from_power(),
         model.system_energy(),
         model.interaction_energy().sum_baths(),
         model.bath_energy().for_bath(0),
         model.bath_energy().for_bath(1),
     ], ["Total", "System", "Interaction", "Cold Bath", "Hot Bath"])):
         linestyle = "dashed" if model == baseline else None
         pu.plot_with_σ(model.t[:1000], val.slice(slice(0, 1000, 1)), ax=ax_full, linestyle=linestyle, color=f"C{j}")
         t, steady_total = ot.val_relative_to_steady(model, val, steady_idx=2)
         pu.plot_with_σ(t, steady_total, ax=ax, label=label if model != baseline else None, linestyle=linestyle, color=f"C{j}")

 ax.legend()
 fs.export_fig(f"energy_change_off_axis", x_scaling=2, y_scaling=0.7)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/b70ea8ff0c68f06605583b0f48771a861e5aae53.svg]]


* Rotating Hamiltonian
Let us brieofly demonstrate the effects of rotating the system
hamiltonian.

** Construction
#+begin_src jupyter-python :tangle tangle/rot.py :results none
 <<boilerplate>>
 import itertools
 from hops.util.dynamic_matrix import ConstantMatrix
#+end_src

#+begin_src jupyter-python :tangle tangle/rot.py
  rot_models = []
  weights = [.3, .5]
  for weight in weights:
      off_ax = sc.make_model(0, 0)
      off_ax.H_bias = ConstantMatrix(weight / 2 * qt.sigmax().full())
      off_ax.normalize_bias = True
      rot_models.append(off_ax)
#+end_src

#+RESULTS:

#+begin_src jupyter-python
  τs = rot_models[0].t
  #plt.plot(τs, np.einsum('tij,ij->t', rot_models[0].H(τs), qt.sigmay().full()).real)
  # plt.plot(τs, abs(rot_models[0].H(τs)[:, 0, 0]))
  # plt.plot(τs, abs(rot_models[0].H(τs)[:, 0, 1]))
  # plt.plot(τs, abs(rot_models[0].H.operator_norm(τs)))
  H = rot_models[0].H
  plt.plot(τs, list(map(lambda t: get_energy_gap(H(t)), τs)), color="black")
#+end_src

#+RESULTS:
:RESULTS:
| <matplotlib.lines.Line2D | at | 0x7f00c44f6cd0> |
[[file:./.ob-jupyter/7a6d38b0d03238b0d00694a60068273f8382ac8f.svg]]
:END:

#+begin_src jupyter-python
  for model in rot_models:
      print(model.energy_gaps[1] - model.energy_gaps[0])
#+end_src

#+RESULTS:
: 0.9783441907246133
: 0.9435188240589354


** Integration
#+begin_src jupyter-python :tangle tangle/rot.py
 ot.integrate_online_multi(rot_models, 80_000, increment=10_000, analyze_kwargs=dict(every=10_000))
#+end_src

#+begin_src jupyter-python
 aux.import_results(other_data_path="taurus/.data", other_results_path="taurus/results", models_to_import=rot_models)
#+end_src

** Analysis
#+begin_src jupyter-python
 for (i, model), weight in zip(enumerate(rot_models), weights):
     f, a = ot.plot_bloch_components(model)
     #ot.plot_bloch_components(off_ax_models[i+2], ax=a, linestyle="--", label=None)

     a.set_title(rf"$r_x={weight}$")
     fs.export_fig(f"bloch_expectation_rot_{weight}", y_scaling=.7)
#+end_src

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/e47b10f766f959556b716834bb8b04f7fad6f9aa.svg]]
[[file:./.ob-jupyter/e08e289587db6444af876ccf358a43308eb79d39.svg]]
:END:

#+begin_src jupyter-python
 for (i, model), weight in zip(enumerate(rot_models), weights):
     f, a = ot.plot_energy(model)
     a.set_title(rf"$r_y={weight}$")
     fs.export_fig(f"full_energy_rot_{weight}", x_scaling=2, y_scaling=1)
#+end_src

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/46aebae6079822280c7af62e1179c5eea48c07cf.svg]]
[[file:./.ob-jupyter/d64002e262380b8ac3289adad61486eafb8743fe.svg]]
:END:


#+begin_src jupyter-python
 for model in rot_models:
     print(model.power(steady_idx=2).value / baseline.power(steady_idx=2).value, model.efficiency(steady_idx=2).value / baseline.efficiency(steady_idx=2).value)
#+end_src

#+RESULTS:
: 0.9291297056238266 0.9345445495028932
: 0.783979849642736 0.804865129162892

#+begin_src jupyter-python
 fig, axs = plt.subplots(ncols=2)
 (ax_full, ax) = axs

 for ax in axs:
     ax.set_xlabel(r"$\tau$")
     ax.set_ylabel(r"$\Delta X$")

 for (i, model) in enumerate([*rot_models[1:], baseline]):
     for j, (val, label) in enumerate(zip([
         model.total_energy_from_power(),
         model.system_energy(),
         model.interaction_energy().sum_baths(),
         model.bath_energy().for_bath(0),
         model.bath_energy().for_bath(1),
     ], ["Total", "System", "Interaction", "Cold Bath", "Hot Bath"])):
         linestyle = "dashed" if model == baseline else None
         pu.plot_with_σ(model.t[:1000], val.slice(slice(0, 1000, 1)), ax=ax_full, linestyle=linestyle, color=f"C{j}")
         t, steady_total = ot.val_relative_to_steady(model, val, steady_idx=2)
         pu.plot_with_σ(t, steady_total, ax=ax, label=label if model != baseline else None, linestyle=linestyle, color=f"C{j}")

 ax.legend()
 fs.export_fig(f"energy_change_rot", x_scaling=2, y_scaling=0.7)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/634ba0cb457f6145c9e22d45d6b78f27ab630a6d.svg]]
