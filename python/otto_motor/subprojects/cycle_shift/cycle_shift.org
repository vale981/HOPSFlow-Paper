:PROPERTIES:
:ID:       c06111fd-d719-433d-a316-c163f6e1d384
:END:
#+PROPERTY: header-args :session otto_cycle_shift :kernel python :pandoc no :async yes :tangle tangle/cycle_shift.py

Having found a prototypical cycle, we now try to shift the timings to
find if there is an improvement.

* Boilerplate
#+name: boilerplate
#+begin_src jupyter-python :results none
    import figsaver as fs
    import plot_utils as pu
    from hiro_models.one_qubit_model import StocProcTolerances
    from hiro_models.otto_cycle import OttoEngine
    import hiro_models.model_auxiliary as aux
    import numpy as np
    import qutip as qt
    import utilities as ut
    import stocproc
    import matplotlib.pyplot as plt
    import otto_utilities as ot

    import ray
    ray.shutdown()

    #ray.init(address='auto')
    ray.init()
    from hops.util.logging_setup import logging_setup
    import logging
    logging_setup(logging.INFO)
    plt.rcParams['figure.figsize'] = (12,4)
#+end_src

* Cycles
As we found in [[id:66cb884e-8724-488d-88da-21b929ffc2bb][finding_relaxation_time.org]], we use a larger coupling
strength to demonstrate strong coupling effects and to limit the cycle time.

#+begin_src jupyter-python
  T = 50
  switch_time = 3. / T
  def make_model(shift_c, shift_h):
      (p_H, p_L) = ot.timings(switch_time, switch_time)

      return OttoEngine(
          δ=[.8, .8],
          ω_c=[2, 2],
          ψ_0=qt.basis([2], [1]),
          description=f"Classic Cycle",
          k_max=5,
          bcf_terms=[6] * 2,
          truncation_scheme="simplex",
          driving_process_tolerances=[StocProcTolerances(1e-3, 1e-3)] * 2,
          thermal_process_tolerances=[StocProcTolerances(1e-3, 1e-3)] * 2,
          T=[0.5, 4],
          therm_methods=["tanhsinh", "tanhsinh"],
          Δ=1,
          num_cycles=3,
          Θ=T,
          dt=0.001,
          timings_H=p_H,
          timings_L=p_L,
          streaming_mode=True,
          shift_to_resonance=(False, False),
          L_shift=(shift_c, shift_h),
      )
#+end_src

#+RESULTS:

Now we need to lay down a grid size.
We start with one dimension and may add another later / dimension.
We shift so that we just overlap with coupling/decoupling and one above.
#+begin_src jupyter-python
  N = 3
  N_over = 1
  step = switch_time / (N-N_over)
  shifts = [round(shift * step, 3) for shift in range(-N, N+1)]
  shifts
#+end_src

#+RESULTS:
| -0.09 | -0.06 | -0.03 | 0.0 | 0.03 | 0.06 | 0.09 |

#+begin_src jupyter-python
  import itertools
  models = [make_model(shift, shift) for shift in shifts]
#+end_src

#+RESULTS:

#+begin_src jupyter-python :tangle no
  ot.plot_cycles(models, bath=0, legend=True)
#+end_src

#+RESULTS:
:RESULTS:
| <Figure | size | 1200x400 | with | 1 | Axes> | <AxesSubplot: | xlabel= | $\tau$ | ylabel= | Operator Norm | > |
[[file:./.ob-jupyter/06bdf2762c4a0b4e357590d4a83b697c240f2985.svg]]
:END:

* Integrate
#+begin_src jupyter-python
  ot.integrate_online_multi(models, 100_000, increment=10_000, analyze_kwargs=dict(every=10_000))
#+end_src
