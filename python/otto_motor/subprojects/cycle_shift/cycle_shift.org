:PROPERTIES:
:ID:       c06111fd-d719-433d-a316-c163f6e1d384
:END:
#+PROPERTY: header-args :session otto_cycle_shift :kernel python :pandoc no :async yes :tangle tangle/cycle_shift.py

Having found a prototypical cycle, we now try to shift the timings to
find if there is an improvement.

* Boilerplate
#+name: boilerplate
#+begin_src jupyter-python :results none
    import figsaver as fs
    import plot_utils as pu
    from hiro_models.one_qubit_model import StocProcTolerances
    from hiro_models.otto_cycle import OttoEngine
    import hiro_models.model_auxiliary as aux
    import numpy as np
    import qutip as qt
    import utilities as ut
    import stocproc
    import matplotlib.pyplot as plt
    import otto_utilities as ot

    import ray
    ray.shutdown()

    #ray.init(address='auto')
    ray.init()
    from hops.util.logging_setup import logging_setup
    import logging
    logging_setup(logging.INFO)
    plt.rcParams['figure.figsize'] = (12,4)
#+end_src

* Cycles
As we found in [[id:66cb884e-8724-488d-88da-21b929ffc2bb][finding_relaxation_time.org]], we use a larger coupling
strength to demonstrate strong coupling effects and to limit the cycle time.

#+begin_src jupyter-python
  T = 50
  def make_model(shift_c, shift_h, switch_t=3.):
      switch_time = switch_t / T
      print(switch_time * 60)
      (p_H, p_L) = ot.timings(switch_time, switch_time)
      return OttoEngine(
          δ=[.7, .7],
          ω_c=[1, 1],
          ψ_0=qt.basis([2], [1]),
          description=f"Classic Cycle",
          k_max=4,
          bcf_terms=[5] * 2,
          truncation_scheme="simplex",
          driving_process_tolerances=[StocProcTolerances(1e-3, 1e-3)] * 2,
          thermal_process_tolerances=[StocProcTolerances(1e-3, 1e-3)] * 2,
          T=[0.5, 4],
          therm_methods=["tanhsinh", "tanhsinh"],
          Δ=1,
          num_cycles=3,
          Θ=60,
          dt=0.001,
          timings_H=p_H,
          timings_L=p_L,
          streaming_mode=True,
          shift_to_resonance=(False, False),
          L_shift=(shift_c, shift_h),
      )
#+end_src

#+RESULTS:

Now we need to lay down a grid size.
We start with one dimension and may add another later / dimension.
We shift so that we just overlap with coupling/decoupling and one above.
#+begin_src jupyter-python
  N = 3
  N_over = 2
  extra_r = 2
  step = 3. / (T*(N-N_over))
  shifts = [round(shift * step, 3) for shift in range(-N, N+1+extra_r)]
  shifts
#+end_src

#+RESULTS:
| -0.18 | -0.12 | -0.06 | 0.0 | 0.06 | 0.12 | 0.18 | 0.24 | 0.3 |

#+begin_src jupyter-python
  import itertools
  models = [make_model(shift, shift) for shift in shifts]
  baseline = models[3]
#+end_src

#+RESULTS:
: 3.5999999999999996
: 3.5999999999999996
: 3.5999999999999996
: 3.5999999999999996
: 3.5999999999999996
: 3.5999999999999996
: 3.5999999999999996
: 3.5999999999999996
: 3.5999999999999996


#+begin_src jupyter-python
  ot.plot_cycle(baseline)
  fs.export_fig("cycle_prototype", y_scaling=.7)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/495fa3fcd9d75d95d5dccfe1617d558cd02fe296.svg]]

#+begin_src jupyter-python :tangle no
  #ot.plot_cycles(models, bath=0, legend=True)
  from itertools import cycle
  lines = ["--","-.",":", "-"]
  linecycler = cycle(lines)

  fig, ax = plt.subplots()
  t = np.linspace(0, models[0].Θ, 1000)
  l, = ax.plot(t, models[0].H.operator_norm(t)/2-.5, linewidth=3, color="lightgrey")
  legend_1 = ax.legend([l], [r"$(||H||-1)/2$"], loc="center left", title="Reference")
  from cycler import cycler
  for model in models:
      ax.plot(t, model.coupling_operators[1].operator_norm(t), label=fr"${model.L_shift[0] * 100:.0f}\%$", linestyle=(next(linecycler)))
  ax.legend(title=r"Shift of $L_h$", fontsize="x-small", ncols=2)
  ax.set_xlabel(r"$\tau$")
  ax.set_ylabel(r"Operator Norm")
  ax.add_artist(legend_1)
  ax.set_xlim((0, models[0].Θ))
  fs.export_fig("cycle_shift_shifts", x_scaling=2, y_scaling=.5)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/c6e8892f607399c43817103a33883910c9028d67.svg]]

** Integrate
#+begin_src jupyter-python
  ot.integrate_online_multi(models, 80_000, increment=10_000, analyze_kwargs=dict(every=10_000))
#+end_src

** CANCELED Analysis
#+begin_src jupyter-python
  for model in models:
    print(model.power(steady_idx=1).value / baseline.power(steady_idx=1).value, model.efficiency(steady_idx=1).value)
#+end_src

#+RESULTS:
: -2.7704455654085876 -2.5219916727767804
: -2.034015641972767 -1.6675487518853185
: 0.571544457513159 0.19650010500179352
: 1.0 0.30209537308799783
: 1.1652434363371367 0.3239348992880912
: 1.6254413169874071 0.3309674632505577
: 1.6802797038561466 0.3190991034856301

#+begin_src jupyter-python
  ot.plot_energy(baseline)
  print(
      fs.tex_value(baseline.system_energy().N,  prefix="N="),
    )

  fs.export_fig("prototype_full_energy", x_scaling=2, y_scaling=1)
#+end_src

#+RESULTS:
:RESULTS:
: \(N=80000\)
[[file:./.ob-jupyter/137c3cc0e9a682fb4dcccd9987cff094cd3a977f.svg]]
:END:

#+begin_src jupyter-python
  def thermal_state(T, Ω):
      ρ = np.array([[np.exp(-Ω/T), 0], [0, 1]])
      ρ /= np.sum(np.diag(ρ))

      return ρ
  import hops.util.utilities
  from hopsflow.util import EnsembleValue
  for model in models[3:4]:
      with aux.get_data(model) as data:
          trace_dist_c = hops.util.utilities.trace_distance(data, relative_to=thermal_state(model.T[0], model.energy_gaps[0]))
          trace_dist_h = hops.util.utilities.trace_distance(data, relative_to=thermal_state(model.T[1], model.energy_gaps[1]))
          f, (a, aa) = plt.subplots(nrows=1, ncols=2)
          print(thermal_state(model.T[0], model.energy_gaps[0]))
          print(thermal_state(model.T[1], model.energy_gaps[1]))
          pu.plot_with_σ(model.t, EnsembleValue(trace_dist_c), ax=a, label=r"$||\rho(\tau)-\rho_c||$")
          pu.plot_with_σ(model.t, EnsembleValue(trace_dist_h), ax=a, label=r"$||\rho(\tau)-\rho_h||$")
          aa.plot(model.t, data.rho_t_accum.mean[:,0,0].real,  label=r"$\rho_{00}$")
          aa.axhline(thermal_state(model.T[1], model.energy_gaps[1])[0,0],  label=r"$\rho_{h,00}$", color="lightgray")
          aa.axhline(thermal_state(model.T[0], model.energy_gaps[0])[0,0],  label=r"$\rho_{c,00}$", color="lightgray")


          a.set_xlim(2*model.Θ, 3*model.Θ)
          aa.set_xlim(2*model.Θ, 3*model.Θ)
          a.plot(model.t, (model.H(model.t)[:, 0, 0] - 1)/2, label="$H_\mathrm{sys}$ Modulation")
          a.set_xlabel(r"$\tau$")
          aa.set_xlabel(r"$\tau$")
          #a.set_xlim(155)
          a.legend()
          aa.legend()
          aa.set_ylim((0.1,.4))
          fs.export_fig("prototype_thermalization", y_scaling=.7, x_scaling=2)
#+end_src

#+RESULTS:
:RESULTS:
#+begin_example
  [[0.11920292 0.        ]
   [0.         0.88079708]]
  [[0.37754067 0.        ]
   [0.         0.62245933]]
  /nix/store/vkzza81mzwyk5br1c6cm67g48xycvmvl-python3-3.9.15-env/lib/python3.9/site-packages/matplotlib/cbook/__init__.py:1369: ComplexWarning: Casting complex values to real discards the imaginary part
    return np.asarray(x, float)
  /nix/store/vkzza81mzwyk5br1c6cm67g48xycvmvl-python3-3.9.15-env/lib/python3.9/site-packages/matplotlib/axes/_axes.py:5340: ComplexWarning: Casting complex values to real discards the imaginary part
    pts[0] = start
  /nix/store/vkzza81mzwyk5br1c6cm67g48xycvmvl-python3-3.9.15-env/lib/python3.9/site-packages/matplotlib/axes/_axes.py:5341: ComplexWarning: Casting complex values to real discards the imaginary part
    pts[N + 1] = end
  /nix/store/vkzza81mzwyk5br1c6cm67g48xycvmvl-python3-3.9.15-env/lib/python3.9/site-packages/matplotlib/axes/_axes.py:5344: ComplexWarning: Casting complex values to real discards the imaginary part
    pts[1:N+1, 1] = dep1slice
  /nix/store/vkzza81mzwyk5br1c6cm67g48xycvmvl-python3-3.9.15-env/lib/python3.9/site-packages/matplotlib/axes/_axes.py:5346: ComplexWarning: Casting complex values to real discards the imaginary part
    pts[N+2:, 1] = dep2slice[::-1]
#+end_example
[[file:./.ob-jupyter/4856874e733d5f5018bed3f93e048cecaf3f50de.svg]]
:END:


#+begin_src jupyter-python
  ot.plot_steady_energy_changes([baseline], 2, label_fn=lambda _: "")
  fs.export_fig("prototype_energy_change", y_scaling=.7)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/7054daf93cfddaccb915ec77b89a8f04d90bbf2d.svg]]


#+begin_src jupyter-python
  ot.plot_power_eff_convergence(models)
  fs.export_fig("cycle_shift_convergence", x_scaling=2, y_scaling=.7)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/0523dcc91c94deb7cdf13ae934a9ad5f734e6a55.svg]]

We see that we get a pretty good picture after about 30k-40k samples.

#+begin_src jupyter-python
  ot.plot_powers_and_efficiencies(np.array(shifts) * 100, models, xlabel="Cycle Shift")
  fs.export_fig("cycle_shift_power_efficiency", y_scaling=.7, x_scaling=1)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/67346bf5a74bfe1c7b184f48ea381df4e50cd11b.svg]]

#+begin_src jupyter-python
  fig, ax =ot.plot_steady_energy_changes([baseline, models[3+2]], 2, label_fn=lambda m: ("baseline" if m.hexhash == baseline.hexhash else "shifted"))
  ax.legend(loc="lower left")
  fs.export_fig("shift_energy_change", y_scaling=.7)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/e302b3e61cd22e6792e1303d0bbbbd74c198a3e4.svg]]


The best shift:
#+begin_src jupyter-python
  best_shift = shifts[3+2]#[np.argmax([-model.power(steady_idx=2).value for model in models])]
  best_shift_model = make_model(best_shift, best_shift)
#+end_src

#+RESULTS:
: 3.5999999999999996

#+begin_src jupyter-python
  t_shift_begin = (2 - best_shift) * baseline.Θ
  t_begin = 2 * baseline.Θ
  t_shift_end = (3 - best_shift) * baseline.Θ
  final_period_idx = np.argmin(abs(baseline.t - t_begin))
  final_period_shifted = np.argmin(abs(baseline.t - t_shift_begin))
  final_period_shifted_end = final_period_shifted - final_period_idx

  t_baseline = baseline.t[final_period_shifted:final_period_shifted_end]
  t_final_period = baseline.t[final_period_idx:]
  t_plot = baseline.t[: len(t_baseline)]
  interaction_change_baseline_cold = (
      baseline.interaction_power()
      .for_bath(0)
      .slice(slice(final_period_shifted, final_period_shifted_end))
      .value
  )
  interaction_change_best_cold = (
      best_shift_model.interaction_power()
      .for_bath(0)
      .slice(slice(final_period_idx, len(baseline.t)))
      .value
  )
  interaction_change_baseline_hot = (
      baseline.interaction_power()
      .for_bath(1)
      .slice(slice(final_period_shifted, final_period_shifted_end))
      .value
  )
  interaction_change_best_hot = (
      best_shift_model.interaction_power()
      .for_bath(1)
      .slice(slice(final_period_idx, len(baseline.t)))
      .value
  )


  fig, ax = plt.subplots()
  ax.plot(t_plot, interaction_change_baseline_cold, label="baseline")
  ax.plot(t_plot, interaction_change_best_cold, label="shifted")
  ax.plot(t_plot, interaction_change_baseline_hot, linestyle="--", color="C0")
  ax.plot(t_plot, interaction_change_best_hot, linestyle="--", color="C1")
  ax.legend()
  ax.set_xlabel(r"$\tau$")
  ax.set_ylabel(r"$P_{\mathrm{int}}$")
  fs.export_fig("shift_power", y_scaling=0.7)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/0a8b5b9bc6d21595b2d1e19fdf2386afe451c3c5.svg]]


#+begin_src jupyter-python
  ot.plot_energy(baseline)
  f, a = ot.plot_energy(best_shift_model)
  a.plot(best_shift_model.t, best_shift_model.H(best_shift_model.t)[:, 0,0])
#+end_src

#+RESULTS:
:RESULTS:
: /nix/store/vkzza81mzwyk5br1c6cm67g48xycvmvl-python3-3.9.15-env/lib/python3.9/site-packages/matplotlib/cbook/__init__.py:1369: ComplexWarning: Casting complex values to real discards the imaginary part
:   return np.asarray(x, float)
| <matplotlib.lines.Line2D | at | 0x7f842620cdc0> |
[[file:./.ob-jupyter/a27e17c2ba730ffef64c68d3a9867998a245d84d.svg]]
[[file:./.ob-jupyter/b6947395240dc2927df2b278655765fafc7ec605.svg]]
:END:


#+begin_src jupyter-python
  f, a = plt.subplots()
  a.axhline(best_shift_model.system_energy().value[np.argmin(abs(best_shift_model.t - model.Θ * 2))], color="gray", linestyle="--")
  r = pu.plot_with_σ(
      best_shift_model.t, best_shift_model.interaction_energy().for_bath(0), ax=a,
      label=r"$\langle H_\mathrm{inter}\rangle$"
  )
  pu.plot_with_σ(
      best_shift_model.t, best_shift_model.system_energy(), ax=a, label=r"$\langle H_\mathrm{sys}\rangle$"
  )
  # a.plot(best_shift_model.t, best_shift_model.H(best_shift_model.t)[:, 0,0])
  a.plot(overlap_models = [overlap(best_shift_model, N, mini_step, new_step_size) for N in Ns]
      best_shift_model.t,
      best_shift_model.coupling_operators[0].operator_norm(best_shift_model.t) / 5,
      label="cold bath modulation",
  )

  # a.plot(
  #     best_shift_model.t,
  #     best_shift_model.coupling_operators[1].operator_norm(best_shift_model.t) / 5,
  #     label="hot bath modulation",
  # )
  a.plot(
      best_shift_model.t, best_shift_model.system.operator_norm(best_shift_model.t) / 5,
      label="system modulation"
  )
  # a.plot(best_shift_model.t, best_shift_model.coupling_operators[1].operator_norm(best_shift_model.t) / 5)
  a.set_xlim((model.Θ * 2, model.Θ * 2 + 7))

  a.set_ylim((-.21, .45))
  a.set_xlabel(r"$\tau$")
  a.legend(loc="upper right", fontsize="x-small")
  fs.export_fig("cold_bath_decoupling", y_scaling=.6)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/b1883cf8528e1cf12e372f86461c4b1c38192792.svg]]


* Explore Coupling Length Dimension for The best performing state
#+begin_src jupyter-python
  def overlap(shift_model, N, step, switch_t=3.):
      switch_time = switch_t / T
      (p_H, p_L) = ot.timings(switch_time, switch_time)
      next_model = shift_model.copy()

      #next_model.timings_H=p_H
      next_model.timings_L=p_L

      (a, b, c, d) = next_model.timings_L[0]
      (e, f, g, h) = next_model.timings_L[1]
      next_step = step * N
      (s1, s2) = next_model.L_shift


      next_model.L_shift = (s1 + next_step, s2 - next_step)
      next_model.timings_L = (
          (a - 2 * next_step, b - 2 * next_step, c, d),
          (e, f, g + 2 * next_step, h + 2 * next_step),
      )
      return next_model


  def overlap_cold(shift_model, N, step):
      next_model = shift_model.copy()
      (a, b, c, d) = next_model.timings_L[0]
      (e, f, g, h) = next_model.timings_L[1]
      next_step = step * N
      (s1, s2) = next_model.L_shift
      next_model.L_shift = (s1 + next_step, s2 - next_step)
      next_model.timings_L = (
          (a - 2 * next_step, b - 2 * next_step, c - next_step, d - next_step),
          (e + next_step, f + next_step, g + 2 * next_step, h + 2 * next_step),
      )
      return next_model


  Ns = list(range(1, 4))[:1]
  overlap_models = [overlap(best_shift_model, N, step) for N in Ns]
  overlap_models = [overlap_cold(best_shift_model, N, step) for N in Ns]
  new_step_size = 6
  mini_step = (new_step_size / (N-N_over) / T)
  print(mini_step)
  overlap_models = [overlap(best_shift_model, N, mini_step, new_step_size) for N in Ns]
#+end_src

#+RESULTS:
: 0.12

#+begin_src jupyter-python :tangle no
  ot.plot_cycles([overlap_models[0]], legend=True)
#+end_src

#+RESULTS:
:RESULTS:
| <Figure | size | 1200x400 | with | 1 | Axes> | <AxesSubplot: | xlabel= | $\tau$ | ylabel= | Operator Norm | > |
[[file:./.ob-jupyter/3a4fbfc08b5aa92173864a5bf5baa909281076e2.svg]]
:END:

** Integrate
#+begin_src jupyter-julia
  all_overlap_models = [best_shift_model, *overlap_models]
#+end_src


#+begin_src jupyter-python
  ot.integrate_online_multi(overlap_models, 80_000, increment=10_000, analyze_kwargs=dict(every=10_000))
#+end_src

** Analysis
#+begin_src jupyter-python :tangle no
  fig, ax = plt.subplots()
  t = np.linspace(0, all_overlap_models[0].Θ, 1000)
  ax.plot(t, all_overlap_models[0].coupling_operators[0].operator_norm(t), color="C1", linewidth=1, label="Shifted")
  ax.plot(t, all_overlap_models[0].coupling_operators[1].operator_norm(t), color="C1", linestyle="--", linewidth=1)
  ax.plot(t, all_overlap_models[1].coupling_operators[0].operator_norm(t), color="C2", linewidth=1, label="Shifted with Overlap")
  ax.plot(t, all_overlap_models[1].coupling_operators[1].operator_norm(t), color="C2", linestyle="--", linewidth=1)

  ax.set_xlabel(r"$\tau$")
  ax.set_ylabel(r"$||L_{h/c}||$")
  ax.legend()
  fs.export_fig("cycle_shift_shift_vs_overlap", y_scaling=.6)
  #ot.plot_cycles(all_overlap_models[0:2], legend=True)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/87df1592c89180bd0acbf7aa75af7506769e85ed.svg]]


#+begin_src jupyter-python
  ot.plot_power_eff_convergence(all_overlap_models, 2)
#+end_src

#+RESULTS:
:RESULTS:
| <Figure | size | 340x320 | with | 2 | Axes> | (<AxesSubplot: xlabel= $N$ ylabel= $P$ > <AxesSubplot: xlabel= $N$ ylabel= $\eta$ >) |
[[file:./.ob-jupyter/e01f809855125e962fb4f56975fb4833b122dd1a.svg]]
:END:

#+begin_src jupyter-python
  f, a= ot.plot_energy(all_overlap_models[-1])
  a.plot(model.t, model.coupling_operators[0].operator_norm(model.t))
  a.plot(model.t, model.coupling_operators[1].operator_norm(model.t))
  a.plot(model.t, model.system.operator_norm(model.t))
#+end_src

#+RESULTS:
:RESULTS:
| <matplotlib.lines.Line2D | at | 0x7ff2b6947400> |
[[file:./.ob-jupyter/6f6fb7a34b89a008d51117d01b0dba6e6341fd8c.svg]]
:END:


#+begin_src jupyter-julia
  [model.power(steady_idx=2).value / best_shift_model.power(steady_idx=2).value for model in all_overlap_models]
#+end_src

#+RESULTS:
| 1.0 | 1.3236593973330115 |

#+begin_src jupyter-julia
  [model.efficiency(steady_idx=2).value / best_shift_model.efficiency(steady_idx=2).value for model in all_overlap_models]
#+end_src

#+RESULTS:
| 1.0 | 1.1230706203655971 |

#+begin_src jupyter-julia
  [model.power(steady_idx=2).N  for model in all_overlap_models]
#+end_src

#+RESULTS:
| 80000 | 80000 |


#+begin_src jupyter-python
  ot.plot_powers_and_efficiencies([0] + Ns, all_overlap_models)
#+end_src

#+RESULTS:
:RESULTS:
| <Figure | size | 340x320 | with | 2 | Axes> | <AxesSubplot: | ylabel= | $-\bar{P}$ | > |
[[file:./.ob-jupyter/0b9adf725182e7385744287f98375c8b39c3471b.svg]]
:END:

#+begin_src jupyter-python
  f, a = plt.subplots()
  a.axhline(0, color="lightgrey")
  for model, label in zip(all_overlap_models[:2], ["Shifted", "Shifted with Overlap"]):
      _, _, lines = pu.plot_with_σ(model.t, model.interaction_power().sum_baths().integrate(model.t), ax=a, label=fr"$W_\mathrm{{int}}$ {label}")
      pu.plot_with_σ(model.t, model.system_power().integrate(model.t), ax=a, color=lines[0][0].get_color(), linestyle="--", label=fr"$W_\mathrm{{sys}}$ {label}")
  a.set_ylabel(r"$W_{\mathrm{int/sys}}$")
  a.set_xlabel(r"$\tau$")
  a.legend()
  fs.export_fig("cycle_shift_shift_vs_overlap_power", x_scaling=2, y_scaling=.6)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/a4e92f194bddc790d251d8118f1bf7592fb58bb7.svg]]

We see that the power boost is solely due to the interaction
modulation.

#+begin_src jupyter-python
    fig, ax =ot.plot_steady_energy_changes(all_overlap_models, 2, label_fn=(lambda m: ["without overlap", "with overlap"][all_overlap_models.index(m)]))
    ax.legend(loc="lower left")

    fs.export_fig("overlap_energy_change", y_scaling=.9)

    fig, ax =ot.plot_steady_work_baths(all_overlap_models, 2, label_fn=(lambda m: ["without overlap", "with overlap"][all_overlap_models.index(m)]))
    ax.legend(loc="lower left")

    fs.export_fig("overlap_energy_change_hot_cold", y_scaling=.9)
#+end_src

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/d3d583097cb68d5e14c035db2a96b21a09bbabbe.svg]]
[[file:./.ob-jupyter/42e003371bf36501fb9b747b5e9e1f9960b60fd3.svg]]
:END:


#+begin_src jupyter-python
  r = pu.plot_with_σ(all_overlap_models[-1].t, all_overlap_models[-1].interaction_energy().for_bath(0))
  # a.plot(all_overlap_models[-1].t, all_overlap_models[-1].H(all_overlap_models[-1].t)[:, 0,0])
  r[1].plot(all_overlap_models[-1].t, all_overlap_models[-1].coupling_operators[0].operator_norm(all_overlap_models[-1].t) / 5)
  r[1].plot(all_overlap_models[-1].t, all_overlap_models[-1].coupling_operators[1].operator_norm(all_overlap_models[-1].t) / 5)
  r[1].set_xlim((model.Θ*2, model.Θ*2+15))
#+end_src

#+RESULTS:
:RESULTS:
| 120.0 | 135.0 |
[[file:./.ob-jupyter/05702081169b9057efd24c51303402f7e774030e.svg]]
:END:

** Slower switching
#+begin_src jupyter-python :results none
    long_models = [make_model(shift, shift, switch_t=6.) for shift in shifts]
#+end_src

#+begin_src jupyter-python
  from itertools import cycle
  lines = ["--","-.",":", "-"]
  linecycler = cycle(lines)

  fig, ax = plt.subplots()
  t = np.linspace(0, long_models[0].Θ, 1000)
  l, = ax.plot(t, long_models[0].H.operator_norm(t)/2-.5, linewidth=3, color="lightgrey")
  legend_1 = ax.legend([l], [r"$(||H||-1)/2$"], loc="center left", title="Reference")
  from cycler import cycler
  for model in long_models:
      ax.plot(t, model.coupling_operators[1].operator_norm(t), label=fr"${model.L_shift[0] * 100:.0f}\%$", linestyle=(next(linecycler)))
  ax.legend(title=r"Shift of $L_h$", fontsize="x-small", ncols=2)
  ax.set_xlabel(r"$\tau$")
  ax.set_ylabel(r"Operator Norm")
  ax.add_artist(legend_1)
  ax.set_xlim((0, long_models[0].Θ))
  fs.export_fig("cycle_shift_long_shifts", x_scaling=2, y_scaling=.5)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/554cf83ca54ff1b718d8ff017baaad5d0eb09669.svg]]


#+begin_src jupyter-python
  ot.integrate_online_multi(long_models, 80_000, increment=10_000, analyze_kwargs=dict(every=10_000))
#+end_src

** Findings
- coupling overlap doesn't help much
- with these parameters the earlier obeservation does not recur
- more scan needed
- maybe slower coupling/decoupling will help
