:PROPERTIES:
:ID:       c06111fd-d719-433d-a316-c163f6e1d384
:END:
#+PROPERTY: header-args :session otto_cycle_shift :kernel python :pandoc no :async yes :tangle tangle/cycle_shift.py :noweb yes

Having found a prototypical cycle, we now try to shift the timings to
find if there is an improvement.

* Boilerplate
#+name: boilerplate
#+begin_src jupyter-python :results none
  import figsaver as fs
  import plot_utils as pu
  from hiro_models.one_qubit_model import StocProcTolerances
  from hiro_models.otto_cycle import OttoEngine
  import hiro_models.model_auxiliary as aux
  import numpy as np
  import qutip as qt
  import utilities as ut
  import stocproc
  import matplotlib.pyplot as plt
  import otto_utilities as ot
  import shift_cycle as sc
  import ray
  ray.shutdown()

  #ray.init(address='auto')
  ray.init()
  from hops.util.logging_setup import logging_setup
  import logging
  logging_setup(logging.INFO)
  plt.rcParams['figure.figsize'] = (12,4)
#+end_src

* Cycles
As we found in [[id:66cb884e-8724-488d-88da-21b929ffc2bb][finding_relaxation_time.org]], we use a larger coupling
strength to demonstrate strong coupling effects and to limit the cycle time.

#+begin_src jupyter-python :tangle tangle/original.py :results none
  <<boilerplate>>
#+end_src

Now we need to lay down a grid size.
We start with one dimension and may add another later / dimension.
We shift so that we just overlap with coupling/decoupling and one above.
#+begin_src jupyter-python :tangle tangle/original.py
  shifts = sc.make_shifts(extra_r=4)
  shifts
#+end_src

#+RESULTS:
: array([-0.18, -0.12, -0.06,  0.  ,  0.06,  0.12,  0.18,  0.24,  0.3 ,
:         0.36,  0.42])

#+begin_src jupyter-python :tangle tangle/original.py
  import itertools
  models = [sc.make_model(shift, shift) for shift in shifts]
  baseline = models[3]
#+end_src

#+RESULTS:
#+begin_example
  3.5999999999999996
  3.5999999999999996
  3.5999999999999996
  3.5999999999999996
  3.5999999999999996
  3.5999999999999996
  3.5999999999999996
  3.5999999999999996
  3.5999999999999996
  3.5999999999999996
  3.5999999999999996
#+end_example


#+begin_src jupyter-python
  ot.plot_cycle(baseline)
  fs.export_fig("cycle_prototype", y_scaling=.7)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/52bc73698a80a2938e44a3276eaeff5aded093cd.svg]]

#+begin_src jupyter-python :tangle no
  #ot.plot_cycles(models, bath=0, legend=True)
  from itertools import cycle
  lines = ["--","-.",":", "-"]
  linecycler = cycle(lines)

  fig, ax = plt.subplots()
  t = np.linspace(0, models[0].Œò, 1000)
  l, = ax.plot(t, models[0].H.operator_norm(t)/2-.5, linewidth=3, color="lightgrey")
  legend_1 = ax.legend([l], [r"$(||H||-1)/2$"], loc="center left", title="Reference")
  from cycler import cycler
  for model in models:
      ax.plot(t, model.coupling_operators[1].operator_norm(t), label=fr"${model.L_shift[0] * 100:.0f}\%$", linestyle=(next(linecycler)))
  ax.legend(title=r"Shift of $L_h$", fontsize="x-small", ncols=2)
  ax.set_xlabel(r"$\tau$")
  ax.set_ylabel(r"Operator Norm")
  ax.add_artist(legend_1)
  ax.set_xlim((0, models[0].Œò))
  fs.export_fig("cycle_shift_shifts", x_scaling=2, y_scaling=.5)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/6c8cd0ac2518b43e36bd407ca0bb146a9f53dac7.svg]]

** Integrate
#+begin_src jupyter-python :tangle tangle/original.py
  ot.integrate_online_multi(models, 80_000, increment=10_000, analyze_kwargs=dict(every=10_000))
#+end_src

** Analysis
#+begin_src jupyter-python
  for model in models:
    print(model.power(steady_idx=1).value / baseline.power(steady_idx=1).value, model.efficiency(steady_idx=1).value)
#+end_src

#+RESULTS:
#+begin_example
  -2.7704455654085876 -2.5219916727767804
  -2.034015641972767 -1.6675487518853185
  0.571544457513159 0.19650010500179352
  1.0 0.30209537308799783
  1.1652434363371367 0.3239348992880912
  1.6254413169874071 0.3309674632505577
  1.6802797038561466 0.3190991034856301
  1.6058539780552505 0.2979616403269744
  1.413212538480568 0.26307105710019735
  0.7332591894799324 0.1434372231954891
  -1.2500012707944386 -0.29523872560546577
#+end_example

#+begin_src jupyter-python
  ot.plot_energy(baseline)
  print(
      fs.tex_value(baseline.system_energy().N,  prefix="N="),
    )

  fs.export_fig("prototype_full_energy", x_scaling=2, y_scaling=1)
#+end_src

#+RESULTS:
:RESULTS:
: \(N=80000\)
[[file:./.ob-jupyter/8dc6d71eabb095e2a21fc5d4050d2e77f8a4d407.svg]]
:END:

#+begin_src jupyter-python
  def thermal_state(T, Œ©):
      œÅ = np.array([[np.exp(-Œ©/T), 0], [0, 1]])
      œÅ /= np.sum(np.diag(œÅ))

      return œÅ
  import hops.util.utilities
  from hopsflow.util import EnsembleValue
  for model in models[3:4]:
      with aux.get_data(model) as data:
          trace_dist_c = hops.util.utilities.trace_distance(data, relative_to=thermal_state(model.T[0], model.energy_gaps[0]))
          trace_dist_h = hops.util.utilities.trace_distance(data, relative_to=thermal_state(model.T[1], model.energy_gaps[1]))
          f, (a, aa) = plt.subplots(nrows=1, ncols=2)
          print(thermal_state(model.T[0], model.energy_gaps[0]))
          print(thermal_state(model.T[1], model.energy_gaps[1]))
          pu.plot_with_œÉ(model.t, EnsembleValue(trace_dist_c), ax=a, label=r"$||\rho(\tau)-\rho_c||$")
          pu.plot_with_œÉ(model.t, EnsembleValue(trace_dist_h), ax=a, label=r"$||\rho(\tau)-\rho_h||$")
          aa.plot(model.t, data.rho_t_accum.mean[:,0,0].real,  label=r"$\rho_{00}$")
          aa.axhline(thermal_state(model.T[1], model.energy_gaps[1])[0,0],  label=r"$\rho_{h,00}$", color="lightgray")
          aa.axhline(thermal_state(model.T[0], model.energy_gaps[0])[0,0],  label=r"$\rho_{c,00}$", color="lightgray")


          a.set_xlim(2*model.Œò, 3*model.Œò)
          aa.set_xlim(2*model.Œò, 3*model.Œò)
          a.plot(model.t, (model.H(model.t)[:, 0, 0] - 1)/2, label="$H_\mathrm{sys}$ Modulation")
          a.set_xlabel(r"$\tau$")
          aa.set_xlabel(r"$\tau$")
          #a.set_xlim(155)
          a.legend()
          aa.legend()
          aa.set_ylim((0.1,.4))
          fs.export_fig("prototype_thermalization", y_scaling=.7, x_scaling=2)
#+end_src

#+RESULTS:
:RESULTS:
: [[0.11920292 0.        ]
:  [0.         0.88079708]]
: [[0.37754067 0.        ]
:  [0.         0.62245933]]
[[file:./.ob-jupyter/d10a82faed83ac74fbdb0a80362cb43f7e44dbac.svg]]
:END:

#+begin_src jupyter-python
  ot.plot_bloch_components(baseline)
  fs.export_fig("state_evolution", y_scaling=.7)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/2055a903d73105290085026649070f77a60ddd40.svg]]


#+begin_src jupyter-python
  ot.plot_steady_energy_changes([baseline], 2, label_fn=lambda _: "")
  fs.export_fig("prototype_energy_change", y_scaling=.7)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/6904e11bd3ec5b85e0c2e0d8d60c91a3940b3b84.svg]]


#+begin_src jupyter-python
  ot.plot_power_eff_convergence(models)
  fs.export_fig("cycle_shift_convergence", x_scaling=2, y_scaling=.7)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/6576fcf3377ebb38995ea45a6571775d4365b7ef.svg]]

We see that we get a pretty good picture after about 30k-40k samples.

#+begin_src jupyter-python
  ot.plot_powers_and_efficiencies(np.array(shifts) * 100, models, xlabel="Cycle Shift")
  fs.export_fig("cycle_shift_power_efficiency", y_scaling=.7, x_scaling=1)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/8e414af41379a102f5e066cb063acdd3a410a6a2.svg]]

#+begin_src jupyter-python
  fig, ax =ot.plot_steady_energy_changes([baseline, models[3+2]], 2, label_fn=lambda m: ("baseline" if m.hexhash == baseline.hexhash else "shifted"))
  ax.legend(loc="lower left")
  fs.export_fig("shift_energy_change", y_scaling=.7)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/e82e58b9e588d336d71900346ebb97ac1ed8fcba.svg]]


The best shift:
#+begin_src jupyter-python
  best_shift = shifts[3+2]#[np.argmax([-model.power(steady_idx=2).value for model in models])]
  best_shift_model = sc.make_model(best_shift, best_shift)
#+end_src

#+RESULTS:
: 3.5999999999999996

#+begin_src jupyter-python
  ot.plot_bloch_components(best_shift_model)
  best_shift_model.hexhash
#+end_src

#+RESULTS:
:RESULTS:
: 7cac0199140ff8f9fb2e0073b950e079e582466b8a6aea99f286d5d81b62cad8
[[file:./.ob-jupyter/b0331e0557f3d5aa3f24e97405ad88d097838be6.svg]]
:END:


#+begin_src jupyter-python
  t_shift_begin = (2 - best_shift) * baseline.Œò
  t_begin = 2 * baseline.Œò
  t_shift_end = (3 - best_shift) * baseline.Œò
  final_period_idx = np.argmin(abs(baseline.t - t_begin))
  final_period_shifted = np.argmin(abs(baseline.t - t_shift_begin))
  final_period_shifted_end = final_period_shifted - final_period_idx

  t_baseline = baseline.t[final_period_shifted:final_period_shifted_end]
  t_final_period = baseline.t[final_period_idx:]
  t_plot = baseline.t[: len(t_baseline)]
  interaction_change_baseline_cold = (
      baseline.interaction_power()
      .for_bath(0)
      .slice(slice(final_period_shifted, final_period_shifted_end))
      .value
  )
  interaction_change_best_cold = (
      best_shift_model.interaction_power()
      .for_bath(0)
      .slice(slice(final_period_idx, len(baseline.t)))
      .value
  )
  interaction_change_baseline_hot = (
      baseline.interaction_power()
      .for_bath(1)
      .slice(slice(final_period_shifted, final_period_shifted_end))
      .value
  )
  interaction_change_best_hot = (
      best_shift_model.interaction_power()
      .for_bath(1)
      .slice(slice(final_period_idx, len(baseline.t)))
      .value
  )


  fig, ax = plt.subplots()
  ax.plot(t_plot, interaction_change_baseline_cold, label="baseline")
  ax.plot(t_plot, interaction_change_best_cold, label="shifted")
  ax.plot(t_plot, interaction_change_baseline_hot, linestyle="--", color="C0")
  ax.plot(t_plot, interaction_change_best_hot, linestyle="--", color="C1")
  ax.legend()
  ax.set_xlabel(r"$\tau$")
  ax.set_ylabel(r"$P_{\mathrm{int}}$")
  fs.export_fig("shift_power", y_scaling=0.7)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/461e4a99905b6a95ee1aa9339dbbe19f90fef570.svg]]


#+begin_src jupyter-python
  ot.plot_energy(baseline)
  f, a = ot.plot_energy(best_shift_model)
  a.plot(best_shift_model.t, best_shift_model.H(best_shift_model.t)[:, 0,0])
#+end_src

#+RESULTS:
:RESULTS:
| <matplotlib.lines.Line2D | at | 0x7f4a54e115b0> |
[[file:./.ob-jupyter/1dfc8faed914b3db9255e2f8148e6dd71674ebe3.svg]]
[[file:./.ob-jupyter/c7199307117d774aea29cabdc27a35366881d724.svg]]
:END:


#+begin_src jupyter-python
  f, a = plt.subplots()
  a.axhline(best_shift_model.system_energy().value[np.argmin(abs(best_shift_model.t - model.Œò * 2))], color="gray", linestyle="--")
  r = pu.plot_with_œÉ(
      best_shift_model.t, best_shift_model.interaction_energy().for_bath(0), ax=a,
      label=r"$\langle H_\mathrm{inter}\rangle$"
  )
  pu.plot_with_œÉ(
      best_shift_model.t, best_shift_model.system_energy(), ax=a, label=r"$\langle H_\mathrm{sys}\rangle$"
  )
  # a.plot(best_shift_model.t, best_shift_model.H(best_shift_model.t)[:, 0,0])
  a.plot(
      best_shift_model.t,
      best_shift_model.coupling_operators[0].operator_norm(best_shift_model.t) / 5,
      label="cold bath modulation",
  )

  # a.plot(
  #     best_shift_model.t,
  #     best_shift_model.coupling_operators[1].operator_norm(best_shift_model.t) / 5,
  #     label="hot bath modulation",
  # )
  a.plot(
      best_shift_model.t, best_shift_model.system.operator_norm(best_shift_model.t) / 5,
      label="system modulation"
  )
  # a.plot(best_shift_model.t, best_shift_model.coupling_operators[1].operator_norm(best_shift_model.t) / 5)
  a.set_xlim((model.Œò * 2, model.Œò * 2 + 7))

  a.set_ylim((-.21, .45))
  a.set_xlabel(r"$\tau$")
  a.legend(loc="upper right", fontsize="x-small")
  fs.export_fig("cold_bath_decoupling", y_scaling=.6)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/6b305bc0d459a215b7c7df707b2fa4704d07a4b3.svg]]


* Explore Coupling Length Dimension for The best performing state
#+begin_src jupyter-python
  def overlap(shift_model, N, step, switch_t=3.):
      switch_time = switch_t / T
      (p_H, p_L) = ot.timings(switch_time, switch_time)
      next_model = shift_model.copy()

      #next_model.timings_H=p_H
      next_model.timings_L=p_L

      (a, b, c, d) = next_model.timings_L[0]
      (e, f, g, h) = next_model.timings_L[1]
      next_step = step * N
      (s1, s2) = next_model.L_shift


      next_model.L_shift = (s1 + next_step, s2 - next_step)
      next_model.timings_L = (
          (a - 2 * next_step, b - 2 * next_step, c, d),
          (e, f, g + 2 * next_step, h + 2 * next_step),
      )
      return next_model


  def overlap_cold(shift_model, N, step):
      next_model = shift_model.copy()
      (a, b, c, d) = next_model.timings_L[0]
      (e, f, g, h) = next_model.timings_L[1]
      next_step = step * N
      (s1, s2) = next_model.L_shift
      next_model.L_shift = (s1 + next_step, s2 - next_step)
      next_model.timings_L = (
          (a - 2 * next_step, b - 2 * next_step, c - next_step, d - next_step),
          (e + next_step, f + next_step, g + 2 * next_step, h + 2 * next_step),
      )
      return next_model


  Ns = list(range(1, 4))[:1]
  overlap_models = [overlap(best_shift_model, N, step) for N in Ns]
  overlap_models = [overlap_cold(best_shift_model, N, step) for N in Ns]
  new_step_size = 6
  mini_step = (new_step_size / (N-N_over) / T)
  print(mini_step)
  overlap_models = [overlap(best_shift_model, N, mini_step, new_step_size) for N in Ns]
#+end_src

#+RESULTS:
: 0.12

#+begin_src jupyter-python :tangle no
  ot.plot_cycles([overlap_models[0]], legend=True)
#+end_src

#+RESULTS:
:RESULTS:
| <Figure | size | 340x320 | with | 1 | Axes> | <AxesSubplot: | xlabel= | $\tau$ | ylabel= | Operator Norm | > |
[[file:./.ob-jupyter/1448dddffc867d28693765ef9638d816846cbb48.svg]]
:END:

** Integrate
#+begin_src jupyter-julia
  all_overlap_models = [best_shift_model, *overlap_models]
#+end_src


#+begin_src jupyter-python
  ot.integrate_online_multi(overlap_models, 80_000, increment=10_000, analyze_kwargs=dict(every=10_000))
#+end_src

** Analysis
#+begin_src jupyter-python :tangle no
  fig, ax = plt.subplots()
  t = np.linspace(0, all_overlap_models[0].Œò, 1000)
  ax.plot(t, all_overlap_models[0].coupling_operators[0].operator_norm(t), color="C1", linewidth=1, label="Shifted")
  ax.plot(t, all_overlap_models[0].coupling_operators[1].operator_norm(t), color="C1", linestyle="--", linewidth=1)
  ax.plot(t, all_overlap_models[1].coupling_operators[0].operator_norm(t), color="C2", linewidth=1, label="Shifted with Overlap")
  ax.plot(t, all_overlap_models[1].coupling_operators[1].operator_norm(t), color="C2", linestyle="--", linewidth=1)

  ax.set_xlabel(r"$\tau$")
  ax.set_ylabel(r"$||L_{h/c}||$")
  ax.legend()
  fs.export_fig("cycle_shift_shift_vs_overlap", y_scaling=.6)
  #ot.plot_cycles(all_overlap_models[0:2], legend=True)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/87df1592c89180bd0acbf7aa75af7506769e85ed.svg]]


#+begin_src jupyter-python
  ot.plot_power_eff_convergence(all_overlap_models, 2)
#+end_src

#+RESULTS:
:RESULTS:
| <Figure | size | 340x320 | with | 2 | Axes> | (<AxesSubplot: xlabel= $N$ ylabel= $P$ > <AxesSubplot: xlabel= $N$ ylabel= $\eta$ >) |
[[file:./.ob-jupyter/e01f809855125e962fb4f56975fb4833b122dd1a.svg]]
:END:

#+begin_src jupyter-python
  f, a= ot.plot_energy(all_overlap_models[-1])
  a.plot(model.t, model.coupling_operators[0].operator_norm(model.t))
  a.plot(model.t, model.coupling_operators[1].operator_norm(model.t))
  a.plot(model.t, model.system.operator_norm(model.t))
#+end_src

#+RESULTS:
:RESULTS:
| <matplotlib.lines.Line2D | at | 0x7ff2b6947400> |
[[file:./.ob-jupyter/6f6fb7a34b89a008d51117d01b0dba6e6341fd8c.svg]]
:END:


#+begin_src jupyter-julia
  [model.power(steady_idx=2).value / best_shift_model.power(steady_idx=2).value for model in all_overlap_models]
#+end_src

#+RESULTS:
| 1.0 | 1.3236593973330115 |

#+begin_src jupyter-julia
  [model.efficiency(steady_idx=2).value / best_shift_model.efficiency(steady_idx=2).value for model in all_overlap_models]
#+end_src

#+RESULTS:
| 1.0 | 1.1230706203655971 |

#+begin_src jupyter-julia
  [model.power(steady_idx=2).N  for model in all_overlap_models]
#+end_src

#+RESULTS:
| 80000 | 80000 |


#+begin_src jupyter-python
  ot.plot_powers_and_efficiencies([0] + Ns, all_overlap_models)
#+end_src

#+RESULTS:
:RESULTS:
| <Figure | size | 340x320 | with | 2 | Axes> | <AxesSubplot: | ylabel= | $-\bar{P}$ | > |
[[file:./.ob-jupyter/0b9adf725182e7385744287f98375c8b39c3471b.svg]]
:END:

#+begin_src jupyter-python
  f, a = plt.subplots()
  a.axhline(0, color="lightgrey")
  for model, label in zip(all_overlap_models[:2], ["Shifted", "Shifted with Overlap"]):
      _, _, lines = pu.plot_with_œÉ(model.t, model.interaction_power().sum_baths().integrate(model.t), ax=a, label=fr"$W_\mathrm{{int}}$ {label}")
      pu.plot_with_œÉ(model.t, model.system_power().integrate(model.t), ax=a, color=lines[0][0].get_color(), linestyle="--", label=fr"$W_\mathrm{{sys}}$ {label}")
  a.set_ylabel(r"$W_{\mathrm{int/sys}}$")
  a.set_xlabel(r"$\tau$")
  a.legend()
  fs.export_fig("cycle_shift_shift_vs_overlap_power", x_scaling=2, y_scaling=.6)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/a4e92f194bddc790d251d8118f1bf7592fb58bb7.svg]]

We see that the power boost is solely due to the interaction
modulation.

#+begin_src jupyter-python
    fig, ax =ot.plot_steady_energy_changes(all_overlap_models, 2, label_fn=(lambda m: ["without overlap", "with overlap"][all_overlap_models.index(m)]))
    ax.legend(loc="lower left")

    fs.export_fig("overlap_energy_change", y_scaling=.9)

    fig, ax =ot.plot_steady_work_baths(all_overlap_models, 2, label_fn=(lambda m: ["without overlap", "with overlap"][all_overlap_models.index(m)]))
    ax.legend(loc="lower left")

    fs.export_fig("overlap_energy_change_hot_cold", y_scaling=.9)
#+end_src

#+RESULTS:
:RESULTS:
# [goto error]
: [0;31m---------------------------------------------------------------------------[0m
: [0;31mNameError[0m                                 Traceback (most recent call last)
: Cell [0;32mIn[206], line 1[0m
: [0;32m----> 1[0m fig, ax [38;5;241m=[39mot[38;5;241m.[39mplot_steady_energy_changes([43mall_overlap_models[49m, [38;5;241m2[39m, label_fn[38;5;241m=[39m([38;5;28;01mlambda[39;00m m: [[38;5;124m"[39m[38;5;124mwithout overlap[39m[38;5;124m"[39m, [38;5;124m"[39m[38;5;124mwith overlap[39m[38;5;124m"[39m][all_overlap_models[38;5;241m.[39mindex(m)]))
: [1;32m      2[0m ax[38;5;241m.[39mlegend(loc[38;5;241m=[39m[38;5;124m"[39m[38;5;124mlower left[39m[38;5;124m"[39m)
: [1;32m      4[0m fs[38;5;241m.[39mexport_fig([38;5;124m"[39m[38;5;124moverlap_energy_change[39m[38;5;124m"[39m, y_scaling[38;5;241m=[39m[38;5;241m.9[39m)
:
: [0;31mNameError[0m: name 'all_overlap_models' is not defined
:END:


#+begin_src jupyter-python
  r = pu.plot_with_œÉ(all_overlap_models[-1].t, all_overlap_models[-1].interaction_energy().for_bath(0))
  # a.plot(all_overlap_models[-1].t, all_overlap_models[-1].H(all_overlap_models[-1].t)[:, 0,0])
  r[1].plot(all_overlap_models[-1].t, all_overlap_models[-1].coupling_operators[0].operator_norm(all_overlap_models[-1].t) / 5)
  r[1].plot(all_overlap_models[-1].t, all_overlap_models[-1].coupling_operators[1].operator_norm(all_overlap_models[-1].t) / 5)
  r[1].set_xlim((model.Œò*2, model.Œò*2+15))
#+end_src

#+RESULTS:
:RESULTS:
| 120.0 | 135.0 |
[[file:./.ob-jupyter/05702081169b9057efd24c51303402f7e774030e.svg]]
:END:

** Slower switching
#+begin_src jupyter-python :results none :tangle tangle/long.py
  <<boilerplate>>
  shifts = sc.make_shifts(extra_r=4)

  long_models = [sc.make_model(shift, shift, switch_t=6., switch_t_sys=3) for shift in shifts]
  long_models = [sc.make_model(shift, shift, switch_t=6.) for shift in shifts]
#+end_src

#+begin_src jupyter-python :tangle no
  fig, ax = plt.subplots()
  t = np.linspace(0, models[0].Œò, 1000)
  ax.plot(t, models[3].coupling_operators[0].operator_norm(t), color="C1", linewidth=1, label="Fast Switching")
  ax.plot(t, models[3].coupling_operators[1].operator_norm(t), color="C1", linestyle="--", linewidth=1)
  ax.plot(t, long_models[3].coupling_operators[0].operator_norm(t), color="C2", linewidth=1, label="Slow Switching")
  ax.plot(t, long_models[3].coupling_operators[1].operator_norm(t), color="C2", linestyle="--", linewidth=1)

  ax.set_xlabel(r"$\tau$")
  ax.set_ylabel(r"$||L_{h/c}||$")
  ax.legend()
  #fs.export_fig("cycle_shift_shift_vs_overlap", y_scaling=.6)
  #ot.plot_cycles(all_overlap_models[0:2], legend=True)
#+end_src

#+RESULTS:
:RESULTS:
: <matplotlib.legend.Legend at 0x7fe0ffae76d0>
[[file:./.ob-jupyter/471bcf75fc64732c2fc4f25ea50b3d129f263072.svg]]
:END:



*** Analysis
#+begin_src jupyter-python
  from itertools import cycle
  lines = ["--","-.",":", "-"]
  linecycler = cycle(lines)

  fig, ax = plt.subplots()
  t = np.linspace(0, long_models[0].Œò, 1000)
  l, = ax.plot(t, long_models[0].H.operator_norm(t)/2-.5, linewidth=3, color="lightgrey")
  legend_1 = ax.legend([l], [r"$(||H||-1)/2$"], loc="center left", title="Reference")
  from cycler import cycler
  for model in [best_shift_model, long_models[5]]:
      ax.plot(t, model.coupling_operators[1].operator_norm(t), label=fr"${model.L_shift[0] * 100:.0f}\%$", linestyle=(next(linecycler)))
      #ax.plot(t, model.coupling_operators[0].operator_norm(t), label=fr"${model.L_shift[0] * 100:.0f}\%$", linestyle=(next(linecycler)))
  ax.legend(title=r"Shift of $L_h$", fontsize="x-small", ncols=2)
  ax.set_xlabel(r"$\tau$")
  ax.set_ylabel(r"Operator Norm")
  ax.add_artist(legend_1)
  ax.set_xlim((0, long_models[0].Œò))
  fs.export_fig("cycle_shift_long_shifts", x_scaling=2, y_scaling=.5)
#+end_src

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/07448a73c1975e4ddc88d7c7dbfcbfc57255a4ad.svg]]
: [2m[36m(pid=gcs_server)[0m [2023-04-04 14:39:14,000 E 868116 868116] (gcs_server) gcs_server.cc:283: Failed to get the resource load: GrpcUnavailable: RPC Error message: Connection reset by peer; RPC Error details:
: [2m[36m(pid=gcs_server)[0m [2023-04-04 14:39:14,000 E 868116 868116] (gcs_server) gcs_server.cc:283: Failed to get the resource load: GrpcUnavailable: RPC Error message: Connection reset by peer; RPC Error details:
: [2m[36m(pid=gcs_server)[0m [2023-04-04 14:39:14,000 E 868116 868116] (gcs_server) gcs_server.cc:283: Failed to get the resource load: GrpcUnavailable: RPC Error message: Connection reset by peer; RPC Error details:
: [2m[36m(pid=gcs_server)[0m [2023-04-04 14:39:14,000 E 868116 868116] (gcs_server) gcs_server.cc:283: Failed to get the resource load: GrpcUnavailable: RPC Error message: Connection reset by peer; RPC Error details:
: [2m[36m(pid=gcs_server)[0m [2023-04-04 14:39:14,000 E 868116 868116] (gcs_server) gcs_server.cc:283: Failed to get the resource load: GrpcUnavailable: RPC Error message: Connection reset by peer; RPC Error details:
:END:


#+begin_src jupyter-python :tangle tangle/long.py
  ot.integrate_online_multi(long_models, 80_000, increment=10_000, analyze_kwargs=dict(every=10_000))
#+end_src

#+begin_src jupyter-python
  long_baseline = long_models[np.argmin(abs(np.array(shifts) - 0))]
  long_baseline = best_shift_model
  for shift, model in zip(shifts, long_models):
      print(
          shift, best_shift,
          model.power(steady_idx=2).N,
          model.power(steady_idx=2).value / long_baseline.power(steady_idx=2).value,
          (model.efficiency(steady_idx=2).value - long_baseline.efficiency(steady_idx=2).value) * 100,
          (model.efficiency(steady_idx=2).value, long_baseline.efficiency(steady_idx=2).value),
      )
#+end_src

#+RESULTS:
: -0.18 0.12 80000 -0.7432352797196996 -98.3933277583729 (-0.6547883379568094, 0.32914493962691976)
: -0.12 0.12 80000 0.5515764970059213 -4.588837155210551 (0.28325656807481425, 0.32914493962691976)
: -0.06 0.12 80000 0.9849641934327689 10.389858999462525 (0.433043529621545, 0.32914493962691976)
: 0.0 0.12 80000 0.9864290608793423 10.386118256193916 (0.4330061221888589, 0.32914493962691976)
: 0.06 0.12 80000 0.9777553355809067 10.616195121156663 (0.4353068908384864, 0.32914493962691976)
: 0.12 0.12 80000 1.1185864670592693 10.712677023075978 (0.43627170985767955, 0.32914493962691976)
: 0.18 0.12 80000 1.280064611377701 7.403981413620636 (0.4031847537631261, 0.32914493962691976)
: 0.24 0.12 80000 1.1867997141496045 2.747192020803302 (0.3566168598349528, 0.32914493962691976)
: 0.3 0.12 80000 0.7281813558728701 -10.479096524510464 (0.22435397438181512, 0.32914493962691976)


#+begin_src jupyter-python
  fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2)
  _, ax1_right = ot.plot_powers_and_efficiencies(np.array(shifts) * 100, models, xlabel="Cycle Shift", ax=ax1)[2]
  _, ax2_right = ot.plot_powers_and_efficiencies(np.array(shifts) * 100, long_models, xlabel="Cycle Shift", ax=ax2)[2]

  ax1_right.sharey(ax2_right)
  ax1.sharey(ax2)

  ax1.set_title("Fast Coupling")
  ax2.set_title("Slow Coupling")
  fs.export_fig("cycle_shift_power_efficiency_with_slower", y_scaling=.7, x_scaling=2)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/136aed41f1e97c8727d923361a130a92097a60ce.svg]]

Aho! The trick is just to slow down the coupling switching.

#+begin_src jupyter-python
  fig, ax =ot.plot_steady_energy_changes([long_models[3+2], models[3+2]], 2, label_fn=lambda m: ("long" if m.hexhash == long_models[3+2].hexhash else "short"))
  ax.legend(loc="lower left")

  #fs.export_fig("shift_energy_change", y_scaling=.7)
#+end_src

#+RESULTS:
:RESULTS:
: <matplotlib.legend.Legend at 0x7f46809d1670>
[[file:./.ob-jupyter/79b743c561edc35e3a3916de2ce83b18cba6c55d.svg]]
:END:

#+begin_src jupyter-python
  powers_long = [-model.power(steady_idx=2).value for model in long_models]
  powers_short = [-model.power(steady_idx=2).value for model in models]
  power_overlap = -overlap_models[0].power(steady_idx=2).value
  plt.plot(shifts, powers_short)
  plt.plot(shifts, powers_long)
  plt.axhline(power_overlap)
#+end_src

#+RESULTS:
:RESULTS:
# [goto error]
: [0;31m---------------------------------------------------------------------------[0m
: [0;31mNameError[0m                                 Traceback (most recent call last)
: Cell [0;32mIn[56], line 3[0m
: [1;32m      1[0m powers_long [38;5;241m=[39m [[38;5;241m-[39mmodel[38;5;241m.[39mpower(steady_idx[38;5;241m=[39m[38;5;241m2[39m)[38;5;241m.[39mvalue [38;5;28;01mfor[39;00m model [38;5;129;01min[39;00m long_models]
: [1;32m      2[0m powers_short [38;5;241m=[39m [[38;5;241m-[39mmodel[38;5;241m.[39mpower(steady_idx[38;5;241m=[39m[38;5;241m2[39m)[38;5;241m.[39mvalue [38;5;28;01mfor[39;00m model [38;5;129;01min[39;00m models]
: [0;32m----> 3[0m power_overlap [38;5;241m=[39m [38;5;241m-[39m[43moverlap_models[49m[[38;5;241m0[39m][38;5;241m.[39mpower(steady_idx[38;5;241m=[39m[38;5;241m2[39m)[38;5;241m.[39mvalue
: [1;32m      4[0m plt[38;5;241m.[39mplot(shifts, powers_short)
: [1;32m      5[0m plt[38;5;241m.[39mplot(shifts, powers_long)
:
: [0;31mNameError[0m: name 'overlap_models' is not defined
:END:

The overlap model still has slightly, but negligible power advantage.


#+begin_src jupyter-python
  efficiencys_long = [model.efficiency(steady_idx=2).value for model in long_models]
  efficiencys_short = [model.efficiency(steady_idx=2).value for model in models]
  efficiency_overlap = overlap_models[0].efficiency(steady_idx=2).value
  plt.plot(shifts, efficiencys_short)
  plt.plot(shifts, efficiencys_long)
  plt.axhline(efficiency_overlap)

#+end_src

#+RESULTS:
:RESULTS:
: <matplotlib.lines.Line2D at 0x7fb7bf86df10>
[[file:./.ob-jupyter/e3ad584293286425efa5f50a7c2037f568438277.svg]]
:END:

Ok, we find that there's nothing special about the overlap model.

Now let's try to find out why the efficiency improved.

#+begin_src jupyter-python
  best_long_model = long_models[5]

  flow_long = -1*best_long_model.bath_energy_flow().for_bath(0)
  power_long = best_long_model.interaction_power().for_bath(0)

  flow_short = -1*best_shift_model.bath_energy_flow().for_bath(0)
  power_short = best_shift_model.interaction_power().for_bath(0)

  plt.plot(best_shift_model.t, flow_short.value, label="fast coupling")
  plt.plot(best_shift_model.t, flow_long.value, label="slow coupling")
  plt.plot(best_shift_model.t, power_short.value, linestyle="--", color="C0")
  plt.plot(best_shift_model.t, power_long.value, linestyle="--",  color="C1")
  plt.xlim((2*best_long_model.Œò-5, 2*best_long_model.Œò+10))
  plt.ylim((-.015,.06))
  plt.legend()
  plt.xlabel(r"$\tau$")
  fs.export_fig("cold_bath_flow", y_scaling=.7)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/ae6cb31c3edef8ef606a639a364d4a25e0442688.svg]]
Way less energy is dumped into the cold bath.

#+begin_src jupyter-python
  t, rel_short_cold = ot.val_relative_to_steady(
      best_shift_model,
      best_shift_model.bath_energy().for_bath(0),
      2,
      1-best_shift_model.L_shift[0]
  )

  t, rel_short_hot = ot.val_relative_to_steady(
      best_shift_model,
      best_shift_model.bath_energy().for_bath(1),
      2,
      1-best_shift_model.L_shift[0]
  )

  t, rel_long_cold = ot.val_relative_to_steady(
      best_long_model,
      best_long_model.bath_energy().for_bath(0),
      2,
      (1-best_long_model.L_shift[0])
  )
  t, rel_long_hot = ot.val_relative_to_steady(
      best_long_model,
      best_long_model.bath_energy().for_bath(1),
      2,
      (1-best_long_model.L_shift[0])
  )
  # plt.plot(t, -(rel_long_cold).value, label="slow coupling")
  # plt.plot(t, -(rel_long_hot).value, label="slow coupling")
  # plt.plot(t, best_long_model.coupling_operators[1].operator_norm(t), label="slow coupling")

  plt.plot(t, -(rel_long_cold/rel_long_hot).value, label="slow coupling")
  plt.plot(t, -(rel_short_cold/rel_short_hot).value, label="fast coupling")
  plt.plot(t, best_long_model.coupling_operators[0].operator_norm(t), color="C0", linestyle="dashed")
  plt.plot(t, best_shift_model.coupling_operators[0].operator_norm(t), color="C1", linestyle="dashed")

  plt.ylim((-.1,.75))
  plt.xlim((100, 128))
  plt.legend()
  plt.xlabel(r"$\tau$")
  plt.ylabel(r"$-\Delta \langle{H_{\mathrm{B},c}}\rangle/\Delta \langle{H_{\mathrm{B},h}}\rangle$")
  fs.export_fig("hot_vs_cold_bath", y_scaling=.7)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/68ae36ac29f3001fc1745d612ccfcba544ef5707.svg]]

#+begin_src jupyter-python
  plt.plot(best_shift_model.t, (best_shift_model.bath_energy().for_bath(0) / best_shift_model.bath_energy().for_bath(1)).value)
  plt.ylim((-1, 1))
#+end_src

#+RESULTS:
:RESULTS:
: /home/hiro/src/hopsflow/hopsflow/util.py:334: RuntimeWarning: invalid value encountered in divide
:   (left_i[2] / right_i[1]) ** 2
| -1.0 | 1.0 |
[[file:./.ob-jupyter/2481b239f61a4fc84617ca79cb91d7ee2c7eae6d.svg]]
:END:


** Slower switching + Only Cold Bath Coupling Shifted
*** Model def and intergration

#+begin_src jupyter-python :tangle tangle/only_cold.py
  <<boilerplate>>
#+end_src

#+RESULTS:

#+begin_src jupyter-python :results none :tangle tangle/only_cold.py
  shifts = sc.make_shifts()
  cold_models = [sc.make_model(shift, shift, switch_t=6., only_cold=True) for shift in shifts]
#+end_src

#+begin_src jupyter-python :tangle tangle/only_cold.py
  ot.integrate_online_multi(cold_models, 80_000, increment=10_000, analyze_kwargs=dict(every=10_000))
#+end_src

*** Cycle showcase
#+begin_src jupyter-python :tangle no
  fig, ax = plt.subplots()
  t = np.linspace(0, models[0].Œò, 1000)
  ax.plot(t, long_models[-3].coupling_operators[0].operator_norm(t), color="C1", linewidth=1, label="both shifted")
  ax.plot(t, long_models[-3].coupling_operators[1].operator_norm(t), color="C1", linestyle="--", linewidth=1)
  ax.plot(t, cold_models[-3].coupling_operators[0].operator_norm(t), color="C2", linewidth=1, linestyle="dotted", label="only cold shifted")
  ax.plot(t, cold_models[-3].coupling_operators[1].operator_norm(t), color="C2", linestyle="--", linewidth=1)
  ax.plot(t, (cold_models[-3].system.operator_norm(t)-1)/2, color="lightgrey", linestyle="--", linewidth=1)

  ax.set_xlabel(r"$\tau$")
  ax.set_ylabel(r"$||L_{h/c}||$")
  ax.legend()
  fs.export_fig("cycle_shift_cold_shift", y_scaling=.6)
  #ot.plot_cycles(all_overlap_models[0:2], legend=True)
#+end_src

#+RESULTS:

[[file:./.ob-jupyter/e3413d8306c7996bd7476d0047a621c7c973187e.svg]]

#+begin_src jupyter-python
  from itertools import cycle
  lines = ["--","-.",":", "-"]
  linecycler = cycle(lines)
  fig, ax = plt.subplots()
  t = np.linspace(0, models[0].Œò, 1000)
  #l, = ax.plot(t, models[0].H.operator_norm(t)/2-.5, linewidth=3, color="lightgrey")
  l, = ax.plot(t, cold_models[3].coupling_operators[1].operator_norm(t), linewidth=3, color="lightgrey")
  legend_1 = ax.legend([l], [r"$(||H||-1)/2$"], loc="center left", title="Reference")
  from cycler import cycler
  for model in cold_models:
      ax.plot(t, model.coupling_operators[0].operator_norm(t), label=fr"${model.L_shift[0] * 100:.0f}\%$", linestyle=(next(linecycler)))
  ax.legend(title=r"Shift of $L_h$", fontsize="x-small", ncols=2)
  ax.set_xlabel(r"$\tau$")
  ax.set_ylabel(r"Operator Norm")
  ax.add_artist(legend_1)
  ax.set_xlim((0, models[0].Œò))
#+end_src

#+RESULTS:
:RESULTS:
| 0.0 | 60.0 |
[[file:./.ob-jupyter/88280474909756e93a10041db2d0af4db2e54edd.svg]]
:END:

#+begin_src jupyter-python
  fig, (ax2, ax1, ax3) = plt.subplots(nrows=1, ncols=3)
  _, ax1_right = ot.plot_powers_and_efficiencies(np.array(shifts) * 100, cold_models, xlabel="Cycle Shift", ax=ax1)[2]
  _, ax2_right = ot.plot_powers_and_efficiencies(np.array(shifts) * 100, long_models, xlabel="Cycle Shift", ax=ax2)[2]
  _, ax3_right = ot.plot_powers_and_efficiencies(np.array(shifts) * 100, models, xlabel="Cycle Shift", ax=ax3)[2]

  ax1_right.sharey(ax2_right)
  ax1.sharey(ax2)

  ax3_right.sharey(ax1_right)
  ax3.sharey(ax1)

  ax1.set_title("Cold Shifted")
  ax2.set_title("Both Shifted")
  fs.export_fig("cycle_shift_power_efficiency_longer_vs_only_cold", y_scaling=.7, x_scaling=2)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/2dba4cb317ec601eaa32575401efb8dcb75a69ea.svg]]

#+begin_src jupyter-python
  ot.plot_multi_powers_and_efficiencies(shifts, [models, long_models, cold_models], ["shifted", "shifted + slower modulation", "slower + only cold shifted"], xlabel=r"Shift $\delta$")
  fs.export_fig("shift_comparison", y_scaling=1, x_scaling=2)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/b1465aa4fa0c0e24f8fa2129d1f2405598f3542f.svg]]

** Findings
- coupling overlap doesn't help much
- with these parameters the earlier obeservation does not recur
- more scan needed
- maybe slower coupling/decoupling will help
