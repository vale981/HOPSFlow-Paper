#+PROPERTY: header-args :session bath_memory :kernel python :pandoc no :async yes

Here we scan bath memory and maybe temperature gradient later.

* Boilerplate
#+name: boilerplate
#+begin_src jupyter-python :results none :tangle tangle/bath_memory.py
  import figsaver as fs
  import plot_utils as pu
  from hiro_models.one_qubit_model import StocProcTolerances
  from hiro_models.otto_cycle import OttoEngine
  import hiro_models.model_auxiliary as aux
  import numpy as np
  import qutip as qt
  import utilities as ut
  import stocproc
  import matplotlib.pyplot as plt
  import otto_utilities as ot
  import hops
  from hopsflow.util import EnsembleValue
  import ray
  ray.shutdown()

  #ray.init(address='auto')
  ray.init()
  from hops.util.logging_setup import logging_setup
  import logging
  logging_setup(logging.INFO)
#+end_src

* Cycles
We take the same baseline as in [[id:c06111fd-d719-433d-a316-c163f6e1d384][cycle_shift.org]].


But we vary the cycle speed while keeping a fixed proportion
coupling-change/cycle time.
#+begin_src jupyter-python :tangle tangle/bath_memory.py
  T = 50

  def make_model_orig(shift_c, shift_h, switch_t=3.0, switch_t_sys=None, only_cold=False):
      switch_time = switch_t / T
      switch_time_sys = (switch_t_sys if switch_t_sys else switch_t) / T

      (p_H, p_L) = ot.timings(switch_time_sys, switch_time)
      return OttoEngine(
          δ=[0.7, 0.7],
          ω_c=[1, 1],
          ψ_0=qt.basis([2], [1]),
          description=f"Classic Cycle",
          k_max=4,
          bcf_terms=[5] * 2,
          truncation_scheme="simplex",
          driving_process_tolerances=[StocProcTolerances(1e-3, 1e-3)] * 2,
          thermal_process_tolerances=[StocProcTolerances(1e-3, 1e-3)] * 2,
          T=[0.5, 4],
          therm_methods=["tanhsinh", "tanhsinh"],
          Δ=1,
          num_cycles=3,
          Θ=60,
          dt=0.001,
          timings_H=p_H,
          timings_L=p_L,
          streaming_mode=True,
          shift_to_resonance=(False, False),
          L_shift=(shift_c, 0 if only_cold else shift_h),
      )

  def make_model(ω_c, T_c):
      model =  make_model_orig(0, 0, switch_t = 6.)


      model.T[0] = T_c
      model.ω_c = [ω_c, ω_c]
      return model
#+end_src

#+RESULTS:


#+begin_src jupyter-python :tangle tangle/bath_memory.py
  ωs = [round(ω, 3) for ω in np.linspace(.5, 1.5, 5)]
  Ts = [round(T, 3) for T in np.linspace(.4, .6, 5)]
  ωs, Ts
#+end_src

#+RESULTS:
| 0.5 | 0.75 | 1.0 | 1.25 | 1.5 |
| 0.4 | 0.45 | 0.5 | 0.55 | 0.6 |

#+begin_src jupyter-python :tangle tangle/bath_memory.py
  import itertools
  models = [make_model(ω, T) for ω, T, in itertools.product(ωs, Ts)]
#+end_src

#+RESULTS:


* Integrate
#+begin_src jupyter-python :tangle tangle/bath_memory.py
  ot.integrate_online_multi(models, 30_000, increment=10_000, analyze_kwargs=dict(every=10_000))
#+end_src

#+begin_src jupyter-python
  aux.import_results(other_data_path="taurus/.data", other_results_path="taurus/results", models_to_import=models)
#+end_src

* Analysis
#+begin_src jupyter-python
  models[1].T
#+end_src

#+RESULTS:
| 0.45 | 4 |

#+begin_src jupyter-python
  fig, ax = plt.subplots()
  for model in models[:22]:
      pu.plot_with_σ(models[0].t, model.interaction_power().sum_baths().integrate(model.t), ax=ax)
      print(model.power(steady_idx=2).value, model.T[0], model.ω_c[0])
#+end_src

#+RESULTS:
:RESULTS:
#+begin_example
  -0.0034551659388595505 0.4 0.5
  -0.002904596596987212 0.45 0.5
  -0.0023659365036140375 0.5 0.5
  -0.0019355134236714987 0.55 0.5
  -0.0014524274934447788 0.6 0.5
  -0.004793786801168995 0.4 0.75
  -0.004345910814395173 0.45 0.75
  -0.003837955397297659 0.5 0.75
  -0.0033846244411344056 0.55 0.75
  -0.0029960642459121102 0.6 0.75
  -0.004871336818211319 0.4 1.0
  -0.004443564282016794 0.45 1.0
  -0.0039839481344293454 0.5 1.0
  -0.0035662462002002022 0.55 1.0
  -0.0031004548905917647 0.6 1.0
  -0.0047150449741200865 0.4 1.25
  -0.004223951236090775 0.45 1.25
  -0.003871633835637403 0.5 1.25
  -0.0034857454518454926 0.55 1.25
  -0.003170841523344448 0.6 1.25
  -0.004713925136010963 0.4 1.5
  -0.004262014237031279 0.45 1.5
#+end_example
[[file:./.ob-jupyter/0717c8898072b9d5d4c6d7ac8e6097ba822e7de8.svg]]
:END:

#+begin_src jupyter-python
  fig, ax = plt.subplots()
  for model in models[:22]:
    pu.plot_with_σ(models[0].t, model.system_energy(), ax=ax)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/64e281864076e8697d6c337f105aeb08bfd9c5e7.svg]]

#+begin_src jupyter-python
  fig, ax = plt.subplots()
  styles = [".", "*"]
  for bath, style in enumerate(styles):
      for i, T in enumerate(Ts):
          inters = np.array([abs(model.interaction_energy().for_bath(bath).slice(slice(model.strobe[1][2], -1))).max.value for model in models[i::len(Ts)]])
          bcf_scales = np.array([(model.bcf_scales[bath]) for model in models[i::len(Ts)]])
          ωs_filter = [model.ω_c[0] for model in models[::len(Ts)]]
          #ax.plot(ωs_filter, inters)
          #ax.plot(ωs_filter, bcf_scales, linestyle=style, marker=".", label=rf"$T={T}$" if bath == 0 else None)
          ax.plot(ωs_filter, inters, linestyle="dashed", marker=style, label=rf"${T}$" if bath == 0 else None, color=f"C{i}")


  ax.set_xlabel(r"$\omega_c$")
  ax.set_ylabel(r"$E_\mathrm{I}$")
  from matplotlib.lines import Line2D
  custom_lines = [Line2D([0], [0], linestyle="dashed", color="black", marker=style) for style in styles]
  legend_orig = ax.legend(title=r"$T_c$")
  ax.legend(custom_lines, ["Cold Bath", "Hot Bath"], loc="upper center", bbox_to_anchor=[0.4, 1])
  ax.add_artist(legend_orig)
  fs.export_fig("bath_memory_interaction_strength", x_scaling=1, y_scaling=.7)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/a6d1361f6b9238fd63a5cce405fdd9209d6f635b.svg]]

#+begin_src jupyter-python
  fig, ax = plt.subplots()
  styles = [".", "*"]
  for bath, style in enumerate(styles):
      for i, T in enumerate(Ts):
          print(T, [(model.T) for model in models[i::len(Ts)]], bath, style)
          inters = np.array([(ot.val_relative_to_steady(
              model,
              -1 * model.interaction_power().for_bath(bath).integrate(model.t) * 1 / model.Θ,
              steady_idx=2,
          )[1].value[-1]) for model in models[i::len(Ts)]])
          bcf_scales = np.array([(model.bcf_scales[bath]) for model in models[i::len(Ts)]])
          ωs_filter = [model.ω_c[0] for model in models[::len(Ts)]]
          #ax.plot(ωs_filter, inters)
          #ax.plot(ωs_filter, bcf_scales, linestyle=style, marker=".", label=rf"$T={T}$" if bath == 0 else None)
          ax.plot(ωs_filter, inters, linestyle="dashed", marker=style, label=rf"${T}$" if bath == 0 else None, color=f"C{i}")


  ax.set_xlabel(r"$\omega_c$")
  ax.set_ylabel(r"$\bar{P}_\mathrm{I}$")
  from matplotlib.lines import Line2D
  custom_lines = [Line2D([0], [0], linestyle="dashed", marker=style, color="black") for style in styles]
  legend_orig = ax.legend(title=r"$T_c$")
  ax.legend(custom_lines, ["Cold Bath", "Hot Bath"], loc="upper center", bbox_to_anchor=[0.6, .56])
  ax.add_artist(legend_orig)
  fs.export_fig("bath_memory_interaction_power", x_scaling=1, y_scaling=.7)
#+end_src

#+RESULTS:
:RESULTS:
#+begin_example
  0.4 [[0.4, 4], [0.4, 4], [0.4, 4], [0.4, 4], [0.4, 4]] 0 .
  0.45 [[0.45, 4], [0.45, 4], [0.45, 4], [0.45, 4], [0.45, 4]] 0 .
  0.5 [[0.5, 4], [0.5, 4], [0.5, 4], [0.5, 4], [0.5, 4]] 0 .
  0.55 [[0.55, 4], [0.55, 4], [0.55, 4], [0.55, 4], [0.55, 4]] 0 .
  0.6 [[0.6, 4], [0.6, 4], [0.6, 4], [0.6, 4], [0.6, 4]] 0 .
  0.4 [[0.4, 4], [0.4, 4], [0.4, 4], [0.4, 4], [0.4, 4]] 1 *
  0.45 [[0.45, 4], [0.45, 4], [0.45, 4], [0.45, 4], [0.45, 4]] 1 *
  0.5 [[0.5, 4], [0.5, 4], [0.5, 4], [0.5, 4], [0.5, 4]] 1 *
  0.55 [[0.55, 4], [0.55, 4], [0.55, 4], [0.55, 4], [0.55, 4]] 1 *
  0.6 [[0.6, 4], [0.6, 4], [0.6, 4], [0.6, 4], [0.6, 4]] 1 *
#+end_example
[[file:./.ob-jupyter/d802e193d6695eb382972e8a3652a157a854a569.svg]]
:END:


#+begin_src jupyter-python
  fig, ax = plt.subplots()
  for model in models[len(Ts)*4:len(Ts)*5]:
      pu.plot_with_σ(model.t, model.interaction_energy().for_bath(1), ax=ax)
      pu.plot_with_σ(model.t, model.system_energy(), ax=ax)
      pu.plot_with_σ(model.t, model.interaction_power().for_bath(1), ax=ax, linestyle="dashed")
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/b69b1130c17be6de63bc0ed992a34fbea26daa18.svg]]


[[file:./.ob-jupyter/b9024c9d49fcea3025a1a688e979b6854d435e3a.svg]]


#+begin_src jupyter-python
  fig, ax = plt.subplots()
  ax.set_xlim(models[0].Θ * 2, models[0].Θ * 3)
  for i, model in enumerate(models[0::len(Ts)]):
      T_c = model.T[0]
      pu.plot_with_σ(model.t, model.interaction_energy().for_bath(0), ax=ax, color=f"C{i}", label=f"{model.ω_c[0]}")
      pu.plot_with_σ(model.t, model.interaction_energy().for_bath(1), ax=ax, color=f"C{i}", linestyle="dotted")
      pu.plot_with_σ(model.t, model.system_energy(), ax=ax, linestyle="dashed", color=f"C{i}")

      #ax.plot(model.t, model.system.operator_norm(model.t), linestyle="dashed", color=f"C{i}")
      #pu.plot_with_σ(model.t, model.interaction_power().for_bath(1), ax=ax, linestyle="dashed")

  custom_lines = [Line2D([0], [0], linestyle=style, color="black") for style in ["-", "dotted", "dashed"]]
  legend_orig = fig.legend(title=r"$\omega_c$", loc="upper center", bbox_to_anchor=[1.1, .7])
  fig.legend(custom_lines, [r"$\langle H_{\mathrm{I},c}\rangle$", r"$\langle H_{\mathrm{I},h}\rangle$", r"$\langle H_{\mathrm{S}}\rangle$"], loc="upper center", bbox_to_anchor=[1.1, 1])
  fig.add_artist(legend_orig)
  ax.set_title(rf"$T_c={T_c}$")
  ax.set_xlabel(r"$\tau$")
  fs.export_fig("bath_memory_constant_t_overview", x_scaling=1, y_scaling=.7)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/253ca412ce97ab193b8e0d63b443a255138f8944.svg]]

#+begin_src jupyter-python
  def thermal_state(T, Ω):
      ρ = np.array([[np.exp(-Ω / T), 0], [0, 1]])
      ρ /= np.sum(np.diag(ρ))

      return ρ
  fig, ax = plt.subplots()
  ax.set_xlim(models[0].Θ * 2, models[0].Θ * 3)

  for i, model in enumerate(models[0::len(Ts)]):
      T_c = model.T[0]
      pu.plot_with_σ(model.t, model.interaction_energy().for_bath(0), ax=ax, color=f"C{i}", label=f"{model.ω_c[0]}")
      pu.plot_with_σ(model.t, model.interaction_energy().for_bath(1), ax=ax, color=f"C{i}", linestyle="dotted")

      with aux.get_data(model) as d:
            pu.plot_with_σ(
                model.t,
                EnsembleValue(
                    hops.util.utilities.trace_distance(
                        d, relative_to=thermal_state(model.T[0], model.energy_gaps[0])
                    )
                ),
                linestyle="dashed",
                color=f"C{i}",
                ax=ax,
            )
            pu.plot_with_σ(
                model.t,
                EnsembleValue(
                    hops.util.utilities.trace_distance(
                        d, relative_to=thermal_state(model.T[1], model.energy_gaps[1])
                    )
                ),
                linestyle="dashdot",
                color=f"C{i}",
                ax=ax,
            )
      #ax.plot(model.t, model.coupling_operators[0].operator_norm(model.t), linestyle="dashed", color=f"C{i}")
      #ax.plot(model.t, model.system.operator_norm(model.t), linestyle="dashed", color=f"C{i}")
      #pu.plot_with_σ(model.t, model.interaction_power().for_bath(1), ax=ax, linestyle="dashed")

  custom_lines = [Line2D([0], [0], linestyle=style, color="black") for style in ["-", "dotted", "dashed", "dashdot"]]
  legend_orig = fig.legend(title=r"$\omega_c$", loc="upper center", bbox_to_anchor=[1.1, .6])
  fig.legend(custom_lines, [r"$\langle H_{\mathrm{I},c}\rangle$", r"$\langle H_{\mathrm{I},h}\rangle$", r"$||\rho(\tau)-\rho_c||$",  r"$||\rho(\tau)-\rho_h||$"], loc="upper center", bbox_to_anchor=[1.15, 1])
  fig.add_artist(legend_orig)
  ax.set_title(rf"$T_c={T_c}$")
  ax.set_xlabel(r"$\tau$")
  fs.export_fig("bath_memory_constant_t_thermalization", x_scaling=1, y_scaling=.7)
#+end_src

#+RESULTS:
:RESULTS:
: /nix/store/y48ylcnfb6lb7447lrmmddfsqcna3a9q-python3-3.9.15-env/lib/python3.9/site-packages/matplotlib/cbook/__init__.py:1369: ComplexWarning: Casting complex values to real discards the imaginary part
:   return np.asarray(x, float)
: /nix/store/y48ylcnfb6lb7447lrmmddfsqcna3a9q-python3-3.9.15-env/lib/python3.9/site-packages/matplotlib/axes/_axes.py:5340: ComplexWarning: Casting complex values to real discards the imaginary part
:   pts[0] = start
: /nix/store/y48ylcnfb6lb7447lrmmddfsqcna3a9q-python3-3.9.15-env/lib/python3.9/site-packages/matplotlib/axes/_axes.py:5341: ComplexWarning: Casting complex values to real discards the imaginary part
:   pts[N + 1] = end
: /nix/store/y48ylcnfb6lb7447lrmmddfsqcna3a9q-python3-3.9.15-env/lib/python3.9/site-packages/matplotlib/axes/_axes.py:5344: ComplexWarning: Casting complex values to real discards the imaginary part
:   pts[1:N+1, 1] = dep1slice
: /nix/store/y48ylcnfb6lb7447lrmmddfsqcna3a9q-python3-3.9.15-env/lib/python3.9/site-packages/matplotlib/axes/_axes.py:5346: ComplexWarning: Casting complex values to real discards the imaginary part
:   pts[N+2:, 1] = dep2slice[::-1]
[[file:./.ob-jupyter/02fe89bca1c7946a8228dce3381435aa45921b6a.svg]]
:END:


#+begin_src jupyter-python
  fig, ax = plt.subplots()
  ax.set_xlim(models[0].Θ * 2, models[0].Θ * 3)


  for i, model in enumerate(models[len(Ts) : 2*len(Ts)]):
      ω_c = model.ω_c[0]
      pu.plot_with_σ(
          model.t,
          model.interaction_energy().for_bath(0),
          ax=ax,
          color=f"C{i}",
          label=f"{model.T[0]}",
      )
      pu.plot_with_σ(
          model.t,
          model.interaction_energy().for_bath(1),
          ax=ax,
          color=f"C{i}",
          linestyle="dotted",
      )
      pu.plot_with_σ(
          model.t, model.system_energy(), ax=ax, linestyle="dashed", color=f"C{i}"
      )

      # ax.plot(model.t, model.coupling_operators[0].operator_norm(model.t), linestyle="dashed", color=f"C{i}")
      # ax.plot(model.t, model.system.operator_norm(model.t), linestyle="dashed", color=f"C{i}")
      # pu.plot_with_σ(model.t, model.interaction_power().for_bath(1), ax=ax, linestyle="dashed")

  custom_lines = [
      Line2D([0], [0], linestyle=style, color="black")
      for style in ["-", "dotted", "dashed"]
  ]
  legend_orig = fig.legend(title=r"$T_c$", loc="upper center", bbox_to_anchor=[1.1, 0.7])
  fig.legend(
      custom_lines,
      [
          r"$\langle H_{\mathrm{I},c}\rangle$",
          r"$\langle H_{\mathrm{I},h}\rangle$",
          r"$\langle H_{\mathrm{S}}\rangle$",
      ],
      loc="upper center",
      bbox_to_anchor=[1.1, 1],
  )
  fig.add_artist(legend_orig)
  ax.set_title(rf"$\omega_c={ω_c}$")
  ax.set_xlabel(r"$\tau$")

  fs.export_fig("bath_memory_constant_omega_overview", x_scaling=1, y_scaling=0.7)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/5229f244f0a611e72d9445d2a9bc66bcb279c11a.svg]]


#+begin_src jupyter-python
  ot.plot_powers_and_efficiencies(np.array(ωs), models[0::len(Ts)], xlabel=r"$\omega_c$")
#+end_src

#+RESULTS:
:RESULTS:
| <Figure | size | 340x320 | with | 2 | Axes> | <AxesSubplot: | xlabel= | $\omega_c$ | ylabel= | $\bar{P}$ | > | (<AxesSubplot: xlabel= $\omega_c$ ylabel= $\bar{P}$ > <AxesSubplot: ylabel= $\eta$ >) |
[[file:./.ob-jupyter/cb7d0dc9bc64c874514e72287385326a2f710625.svg]]
:END:



#+begin_src jupyter-python
  ot.plot_power_eff_convergence(models, 2)
#+end_src

#+RESULTS:
:RESULTS:
| <Figure | size | 340x320 | with | 2 | Axes> | (<AxesSubplot: xlabel= $N$ ylabel= $P$ > <AxesSubplot: xlabel= $N$ ylabel= $\eta$ >) |
[[file:./.ob-jupyter/6384006b2616a827ceb6cd032b029cbccf0773f3.svg]]
:END:



#+begin_src jupyter-python
  f = plt.figure()
  a_power = f.add_subplot(121, projection="3d")
  a_efficiency = f.add_subplot(122, projection="3d")

  for ax in [a_power, a_efficiency]:
      ax.set_box_aspect(aspect=None, zoom=0.78)
      ax.set_xlabel(r"$T_c$")
      ax.set_ylabel(r"$\omega_c$")
      ax.xaxis.labelpad = 10
      ax.view_init(elev=30.0, azim=-29, roll=0)

  ot.plot_3d_heatmap(
      models,
      lambda model: np.clip(-model.power(steady_idx=2).value, 0, np.inf),
      lambda model: model.T[0],
      lambda model: model.ω_c[0],
      ax=a_power,
  )
  a_power.set_zlabel(r"$\bar{P}$")


  ot.plot_3d_heatmap(
      models,
      lambda model: np.clip(np.nan_to_num(model.efficiency(steady_idx=2).value * 100), 0, np.inf),
      lambda model: model.T[0],
      lambda model: model.ω_c[0],
      ax=a_efficiency,
  )
  a_efficiency.set_zlabel(r"$\eta$")
  fs.export_fig("bath_memory_power_efficiency", x_scaling=2, y_scaling=1)
#+end_src

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/22b8e23a40d90760837338c77db60ceb8f46b39e.svg]]
: [2m[36m(pid=gcs_server)[0m [2023-05-18 16:55:57,199 E 126618 126618] (gcs_server) gcs_server.cc:283: Failed to get the resource load: GrpcUnavailable: RPC Error message: Connection reset by peer; RPC Error details:
: [2m[36m(pid=gcs_server)[0m [2023-05-18 16:55:57,199 E 126618 126618] (gcs_server) gcs_server.cc:283: Failed to get the resource load: GrpcUnavailable: RPC Error message: Connection reset by peer; RPC Error details:
: [2m[36m(pid=gcs_server)[0m [2023-05-18 16:55:57,199 E 126618 126618] (gcs_server) gcs_server.cc:283: Failed to get the resource load: GrpcUnavailable: RPC Error message: Connection reset by peer; RPC Error details:
: [2m[36m(pid=gcs_server)[0m [2023-05-18 16:55:57,199 E 126618 126618] (gcs_server) gcs_server.cc:283: Failed to get the resource load: GrpcUnavailable: RPC Error message: Connection reset by peer; RPC Error details:
: [2m[36m(pid=gcs_server)[0m [2023-05-18 16:55:57,200 E 126618 126618] (gcs_server) gcs_server.cc:283: Failed to get the resource load: GrpcUnavailable: RPC Error message: Connection reset by peer; RPC Error details:
:END:

#+begin_src jupyter-python
  for model in models:
      ot.plot_bloch_components(model)
#+end_src

#+RESULTS:
:RESULTS:
: /home/hiro/Documents/Projects/UNI/master/eflow_paper/python/otto_motor/subprojects/bath_memory/plot_utils.py:38: RuntimeWarning: More than 20 figures have been opened. Figures created through the pyplot interface (`matplotlib.pyplot.figure`) are retained until explicitly closed and may consume too much memory. (To control this warning, see the rcParam `figure.max_open_warning`). Consider using `matplotlib.pyplot.close()`.
:   fig, ax = setup_function()
[[file:./.ob-jupyter/ca6f8c77e0d1c2c4c0588a27f1d5a73f06959b28.svg]]
[[file:./.ob-jupyter/9f04f59f958f8cd05e7fcfae012822448e28a0fa.svg]]
[[file:./.ob-jupyter/7e64dd5c305b62d7e61c8d54061ba0d5c0bd9c71.svg]]
[[file:./.ob-jupyter/a1049ebdd7cfc3033bda8fa6d8db69c76b10c5d4.svg]]
[[file:./.ob-jupyter/6f7c25ffff1125b68ed93c42984b3fbdbc623e4f.svg]]
[[file:./.ob-jupyter/bd8ed043725eac4e7087ce04a8f79cb6dd550bea.svg]]
[[file:./.ob-jupyter/b9f416d4b1330798fc77fc4e38c6ec544c84a2ad.svg]]
[[file:./.ob-jupyter/b7f019626c425b7fd2e28f1d70953cd433a26848.svg]]
[[file:./.ob-jupyter/fdde454c6d1a1e31736ab2f26b35c64424e217f3.svg]]
[[file:./.ob-jupyter/e0af7e1701860e27f7e3fe45f05b8c7c7bf21925.svg]]
[[file:./.ob-jupyter/af151eefe6085deb9679052c683cd68c4d511ade.svg]]
[[file:./.ob-jupyter/28b0b7edde79a9c047b455633716a30c742dcd8f.svg]]
[[file:./.ob-jupyter/471db72082118a478b1ca5e58ac27511fdb93ad5.svg]]
[[file:./.ob-jupyter/66c1ff99f83e6c30af2feb9341d02522d77dde69.svg]]
[[file:./.ob-jupyter/623e14113817b5d8f1074943abccdb7caa0c0bb0.svg]]
[[file:./.ob-jupyter/675689df6d994ce4b35bb864a382f9d7d285b248.svg]]
[[file:./.ob-jupyter/1ac491c0d095e16d95afe9602af94955acde385f.svg]]
[[file:./.ob-jupyter/41bcaaaa18868654a7a90a5f911a994028d3d3e8.svg]]
[[file:./.ob-jupyter/0bc90e1a20c538d634aa21afed202d1c2648222a.svg]]
[[file:./.ob-jupyter/b4790ef001a8c49fdf9a178196428c3ccdb95d25.svg]]
[[file:./.ob-jupyter/70822f7bcdb6cffa813ca2c828a59e6b3307d4ef.svg]]
[[file:./.ob-jupyter/7bcf53ab551180350c7516d1cd29b3c0608229b7.svg]]
[[file:./.ob-jupyter/6375902d049d7c66e42fc1ef593ce9a109b5992c.svg]]
[[file:./.ob-jupyter/9911ddfe7318ac880f7254510fc9dd449cf1a11d.svg]]
[[file:./.ob-jupyter/2b14a9fdd7d143dbeeba0b108a2df8c49e853c01.svg]]
:END:

* Things to Look At
- power and efficiency
- interaction power
