#+PROPERTY: header-args :session bath_memory :kernel python :pandoc no :async yes

Here we scan bath memory and maybe temperature gradient later.

* Boilerplate
#+name: boilerplate
#+begin_src jupyter-python :results none :tangle tangle/bath_memory.py
  import figsaver as fs
  import plot_utils as pu
  from hiro_models.one_qubit_model import StocProcTolerances
  from hiro_models.otto_cycle import OttoEngine
  import hiro_models.model_auxiliary as aux
  import numpy as np
  import qutip as qt
  import utilities as ut
  import stocproc
  import matplotlib.pyplot as plt
  import otto_utilities as ot
  import hops
  from hopsflow.util import EnsembleValue
  import ray
  ray.shutdown()

  #ray.init(address='auto')
  ray.init()
  from hops.util.logging_setup import logging_setup
  import logging
  logging_setup(logging.INFO)
#+end_src

* Cycles
We take the same baseline as in [[id:c06111fd-d719-433d-a316-c163f6e1d384][cycle_shift.org]].


But we vary the cycle speed while keeping a fixed proportion
coupling-change/cycle time.
#+begin_src jupyter-python :tangle tangle/bath_memory.py
  T = 50

  def make_model_orig(shift_c, shift_h, switch_t=3.0, switch_t_sys=None, only_cold=False):
      switch_time = switch_t / T
      switch_time_sys = (switch_t_sys if switch_t_sys else switch_t) / T

      (p_H, p_L) = ot.timings(switch_time_sys, switch_time)
      return OttoEngine(
          δ=[0.7, 0.7],
          ω_c=[1, 1],
          ψ_0=qt.basis([2], [1]),
          description=f"Classic Cycle",
          k_max=4,
          bcf_terms=[5] * 2,
          truncation_scheme="simplex",
          driving_process_tolerances=[StocProcTolerances(1e-3, 1e-3)] * 2,
          thermal_process_tolerances=[StocProcTolerances(1e-3, 1e-3)] * 2,
          T=[0.5, 4],
          therm_methods=["tanhsinh", "tanhsinh"],
          Δ=1,
          num_cycles=3,
          Θ=60,
          dt=0.001,
          timings_H=p_H,
          timings_L=p_L,
          streaming_mode=True,
          shift_to_resonance=(False, False),
          L_shift=(shift_c, 0 if only_cold else shift_h),
      )

  def make_model(ω_c, T_c):
      model =  make_model_orig(0, 0, switch_t = 6.)


      model.T[0] = T_c
      model.ω_c = [ω_c, ω_c]
      return model
#+end_src

#+RESULTS:


#+begin_src jupyter-python :tangle tangle/bath_memory.py
  ωs = [round(ω, 3) for ω in np.linspace(.5, 1.5, 5)]
  Ts = [round(T, 3) for T in np.linspace(.4, .6, 5)]
  ωs, Ts
#+end_src

#+RESULTS:
| 0.5 | 0.75 | 1.0 | 1.25 | 1.5 |
| 0.4 | 0.45 | 0.5 | 0.55 | 0.6 |

#+begin_src jupyter-python :tangle tangle/bath_memory.py
  import itertools
  models = [make_model(ω, T) for ω, T, in itertools.product(ωs, Ts)]
#+end_src

#+RESULTS:


* Integrate
#+begin_src jupyter-python :tangle tangle/bath_memory.py
  ot.integrate_online_multi(models, 30_000, increment=10_000, analyze_kwargs=dict(every=10_000))
#+end_src

#+begin_src jupyter-python
  aux.import_results(other_data_path="taurus/.data", other_results_path="taurus/results", models_to_import=models)
#+end_src

* Analysis
#+begin_src jupyter-python
  models[1].T
#+end_src

#+RESULTS:
| 0.45 | 4 |

#+begin_src jupyter-python
  fig, ax = plt.subplots()
  for model in models:
      pu.plot_with_σ(models[0].t, model.interaction_power().sum_baths().integrate(model.t), ax=ax)
      print(model.system_energy().N, model.power(steady_idx=2).value, model.T[0], model.ω_c[0])
#+end_src

#+RESULTS:
:RESULTS:
#+begin_example
  80000 -0.0035256859094574657 0.4 0.5
  80000 -0.003003232549170266 0.45 0.5
  80000 -0.002486223631053281 0.5 0.5
  80000 -0.002031171680593496 0.55 0.5
  80000 -0.0015762813191599482 0.6 0.5
  [WARNING root                      142566] Adding values with unequal snapshot count discards the snapshots.
  80000 -0.004799000397073388 0.4 0.75
  80000 -0.0043251633398041734 0.45 0.75
  80000 -0.0038327711397568402 0.5 0.75
  80000 -0.0034164331023658415 0.55 0.75
  80000 -0.0030187130898665132 0.6 0.75
  80000 -0.004801786634051003 0.4 1.0
  80000 -0.00434091475109094 0.45 1.0
  80000 -0.003910766374706591 0.5 1.0
  80000 -0.0034755454875544786 0.55 1.0
  80000 -0.0030651376043712942 0.6 1.0
  80000 -0.004734363159180772 0.4 1.25
  80000 -0.004263187042045658 0.45 1.25
  80000 -0.003857041901181338 0.5 1.25
  80000 -0.00346715373726747 0.55 1.25
  80000 -0.003096942043813691 0.6 1.25
  [WARNING root                      142566] Adding values with unequal snapshot count discards the snapshots.
  80000 -0.004676219366752152 0.4 1.5
  80000 -0.004230301763725065 0.45 1.5
  80000 -0.0038056213003110195 0.5 1.5
  80000 -0.0034230466153926742 0.55 1.5
  80000 -0.003075466706937633 0.6 1.5
#+end_example
[[file:./.ob-jupyter/551a6d3eda70b32bf49c903c03bd14899634183c.svg]]
:END:

#+begin_src jupyter-python
  fig, ax = plt.subplots()
  for model in models:
    pu.plot_with_σ(models[0].t, model.system_energy(), ax=ax)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/31011c08fcf8cb9aab5b6fb5e9479c830b5523ce.svg]]

#+begin_src jupyter-python
    for model in models:
        plt.plot(model.t, abs(model.total_energy_from_power().value - model.total_energy().value))
#+end_src

#+RESULTS:
:RESULTS:
: [WARNING root                      241349] Adding values with unequal snapshot count discards the snapshots.
[[file:./.ob-jupyter/5f60ec2379fadc805d6dd4073ac4a3fc64e04b29.svg]]
:END:


#+begin_src jupyter-python
  fig, ax = plt.subplots()
  styles = [".", "*"]
  for bath, style in enumerate(styles):
      for i, T in enumerate(Ts):
          inters = np.array([abs(model.interaction_energy().for_bath(bath).slice(slice(model.strobe[1][2], -1))).max.value for model in models[i::len(Ts)]])
          bcf_scales = np.array([(model.bcf_scales[bath]) for model in models[i::len(Ts)]])
          ωs_filter = [model.ω_c[0] for model in models[::len(Ts)]]
          #ax.plot(ωs_filter, inters)
          #ax.plot(ωs_filter, bcf_scales, linestyle=style, marker=".", label=rf"$T={T}$" if bath == 0 else None)
          ax.plot(ωs_filter, inters, linestyle="dashed", marker=style, label=rf"${T}$" if bath == 0 else None, color=f"C{i}")


  ax.set_xlabel(r"$\omega_c$")
  ax.set_ylabel(r"$E_\mathrm{I}$")
  from matplotlib.lines import Line2D
  custom_lines = [Line2D([0], [0], linestyle="dashed", color="black", marker=style) for style in styles]
  legend_orig = ax.legend(title=r"$T_c$")
  ax.legend(custom_lines, ["Cold Bath", "Hot Bath"], loc="upper center", bbox_to_anchor=[0.4, 1])
  ax.add_artist(legend_orig)
  fs.export_fig("bath_memory_interaction_strength", x_scaling=1, y_scaling=.7)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/3d747faae890aff5b004df68059ffb918e14d0ae.svg]]

#+begin_src jupyter-python
  fig, ax = plt.subplots()
  styles = [".", "*"]
  for bath, style in enumerate(styles):
      for i, T in enumerate(Ts):
          print(T, [(model.T) for model in models[i::len(Ts)]], bath, style)
          inters = np.array([(ot.val_relative_to_steady(
              model,
              -1 * model.interaction_power().for_bath(bath).integrate(model.t) * 1 / model.Θ,
              steady_idx=2,
          )[1].value[-1]) for model in models[i::len(Ts)]])
          bcf_scales = np.array([(model.bcf_scales[bath]) for model in models[i::len(Ts)]])
          ωs_filter = [model.ω_c[0] for model in models[::len(Ts)]]
          #ax.plot(ωs_filter, inters)
          #ax.plot(ωs_filter, bcf_scales, linestyle=style, marker=".", label=rf"$T={T}$" if bath == 0 else None)
          ax.plot(ωs_filter, inters, linestyle="dashed", marker=style, label=rf"${T}$" if bath == 0 else None, color=f"C{i}")


  ax.set_xlabel(r"$\omega_c$")
  ax.set_ylabel(r"$\bar{P}_\mathrm{I}$")
  from matplotlib.lines import Line2D
  custom_lines = [Line2D([0], [0], linestyle="dashed", marker=style, color="black") for style in styles]
  legend_orig = ax.legend(title=r"$T_c$")
  ax.legend(custom_lines, ["Cold Bath", "Hot Bath"], loc="upper center", bbox_to_anchor=[0.6, .56])
  ax.add_artist(legend_orig)
  fs.export_fig("bath_memory_interaction_power", x_scaling=1, y_scaling=.7)
#+end_src

#+RESULTS:
:RESULTS:
#+begin_example
  0.4 [[0.4, 4], [0.4, 4], [0.4, 4], [0.4, 4], [0.4, 4]] 0 .
  0.45 [[0.45, 4], [0.45, 4], [0.45, 4], [0.45, 4], [0.45, 4]] 0 .
  0.5 [[0.5, 4], [0.5, 4], [0.5, 4], [0.5, 4], [0.5, 4]] 0 .
  0.55 [[0.55, 4], [0.55, 4], [0.55, 4], [0.55, 4], [0.55, 4]] 0 .
  0.6 [[0.6, 4], [0.6, 4], [0.6, 4], [0.6, 4], [0.6, 4]] 0 .
  0.4 [[0.4, 4], [0.4, 4], [0.4, 4], [0.4, 4], [0.4, 4]] 1 *
  0.45 [[0.45, 4], [0.45, 4], [0.45, 4], [0.45, 4], [0.45, 4]] 1 *
  0.5 [[0.5, 4], [0.5, 4], [0.5, 4], [0.5, 4], [0.5, 4]] 1 *
  0.55 [[0.55, 4], [0.55, 4], [0.55, 4], [0.55, 4], [0.55, 4]] 1 *
  0.6 [[0.6, 4], [0.6, 4], [0.6, 4], [0.6, 4], [0.6, 4]] 1 *
#+end_example
[[file:./.ob-jupyter/fcabeb7c6f63fc7bc1d6d2a8f82c5a9eaf839bc7.svg]]
:END:


#+begin_src jupyter-python
  fig, ax = plt.subplots()
  for model in models[len(Ts)*4:len(Ts)*5]:
      pu.plot_with_σ(model.t, model.interaction_energy().for_bath(1), ax=ax)
      pu.plot_with_σ(model.t, model.system_energy(), ax=ax)
      pu.plot_with_σ(model.t, model.interaction_power().for_bath(1), ax=ax, linestyle="dashed")
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/112a8c6e447f4211f90e5db647df83a97bdfb292.svg]]


#+begin_src jupyter-python
  fig, ax = plt.subplots()
  ax.set_xlim(models[0].Θ * 2, models[0].Θ * 3)
  for i, model in enumerate(models[0::len(Ts)]):
      T_c = model.T[0]
      pu.plot_with_σ(model.t, model.interaction_energy().for_bath(0), ax=ax, color=f"C{i}", label=f"{model.ω_c[0]}")
      pu.plot_with_σ(model.t, model.interaction_energy().for_bath(1), ax=ax, color=f"C{i}", linestyle="dotted")
      pu.plot_with_σ(model.t, model.system_energy(), ax=ax, linestyle="dashed", color=f"C{i}")

      #ax.plot(model.t, model.system.operator_norm(model.t), linestyle="dashed", color=f"C{i}")
      #pu.plot_with_σ(model.t, model.interaction_power().for_bath(1), ax=ax, linestyle="dashed")

  custom_lines = [Line2D([0], [0], linestyle=style, color="black") for style in ["-", "dotted", "dashed"]]
  legend_orig = fig.legend(title=r"$\omega_c$", loc="upper center", bbox_to_anchor=[1.1, .7])
  fig.legend(custom_lines, [r"$\langle H_{\mathrm{I},c}\rangle$", r"$\langle H_{\mathrm{I},h}\rangle$", r"$\langle H_{\mathrm{S}}\rangle$"], loc="upper center", bbox_to_anchor=[1.1, 1])
  fig.add_artist(legend_orig)
  ax.set_title(rf"$T_c={T_c}$")
  ax.set_xlabel(r"$\tau$")
  fs.export_fig("bath_memory_constant_t_overview", x_scaling=1, y_scaling=.7)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/8ef5c4a0dfcaa4b6b15229c7e03690990bda22ea.svg]]

#+begin_src jupyter-python
  def thermal_state(T, Ω):
      ρ = np.array([[np.exp(-Ω / T), 0], [0, 1]])
      ρ /= np.sum(np.diag(ρ))

      return ρ
  fig, ax = plt.subplots()
  ax.set_xlim(models[0].Θ * 2, models[0].Θ * 3)

  for i, model in enumerate(models[0::len(Ts)]):
      T_c = model.T[0]
      pu.plot_with_σ(model.t, model.interaction_energy().for_bath(0), ax=ax, color=f"C{i}", label=f"{model.ω_c[0]}")
      pu.plot_with_σ(model.t, model.interaction_energy().for_bath(1), ax=ax, color=f"C{i}", linestyle="dotted")

      with aux.get_data(model) as d:
            pu.plot_with_σ(
                model.t,
                EnsembleValue(
                    hops.util.utilities.trace_distance(
                        d, relative_to=thermal_state(model.T[0], model.energy_gaps[0])
                    )
                ),
                linestyle="dashed",
                color=f"C{i}",
                ax=ax,
            )
            pu.plot_with_σ(
                model.t,
                EnsembleValue(
                    hops.util.utilities.trace_distance(
                        d, relative_to=thermal_state(model.T[1], model.energy_gaps[1])
                    )
                ),
                linestyle="dashdot",
                color=f"C{i}",
                ax=ax,
            )
      #ax.plot(model.t, model.coupling_operators[0].operator_norm(model.t), linestyle="dashed", color=f"C{i}")
      #ax.plot(model.t, model.system.operator_norm(model.t), linestyle="dashed", color=f"C{i}")
      #pu.plot_with_σ(model.t, model.interaction_power().for_bath(1), ax=ax, linestyle="dashed")

  custom_lines = [Line2D([0], [0], linestyle=style, color="black") for style in ["-", "dotted", "dashed", "dashdot"]]
  legend_orig = fig.legend(title=r"$\omega_c$", loc="upper center", bbox_to_anchor=[1.1, .6])
  fig.legend(custom_lines, [r"$\langle H_{\mathrm{I},c}\rangle$", r"$\langle H_{\mathrm{I},h}\rangle$", r"$||\rho(\tau)-\rho_c||$",  r"$||\rho(\tau)-\rho_h||$"], loc="upper center", bbox_to_anchor=[1.15, 1])
  fig.add_artist(legend_orig)
  ax.set_title(rf"$T_c={T_c}$")
  ax.set_xlabel(r"$\tau$")
  fs.export_fig("bath_memory_constant_t_thermalization", x_scaling=1, y_scaling=.7)
#+end_src

#+RESULTS:
:RESULTS:
: /nix/store/fai1b55231rnk4jyj0kjicdnqcgdf9ph-python3-3.9.15-env/lib/python3.9/site-packages/matplotlib/cbook/__init__.py:1369: ComplexWarning: Casting complex values to real discards the imaginary part
:   return np.asarray(x, float)
: /nix/store/fai1b55231rnk4jyj0kjicdnqcgdf9ph-python3-3.9.15-env/lib/python3.9/site-packages/matplotlib/axes/_axes.py:5340: ComplexWarning: Casting complex values to real discards the imaginary part
:   pts[0] = start
: /nix/store/fai1b55231rnk4jyj0kjicdnqcgdf9ph-python3-3.9.15-env/lib/python3.9/site-packages/matplotlib/axes/_axes.py:5341: ComplexWarning: Casting complex values to real discards the imaginary part
:   pts[N + 1] = end
: /nix/store/fai1b55231rnk4jyj0kjicdnqcgdf9ph-python3-3.9.15-env/lib/python3.9/site-packages/matplotlib/axes/_axes.py:5344: ComplexWarning: Casting complex values to real discards the imaginary part
:   pts[1:N+1, 1] = dep1slice
: /nix/store/fai1b55231rnk4jyj0kjicdnqcgdf9ph-python3-3.9.15-env/lib/python3.9/site-packages/matplotlib/axes/_axes.py:5346: ComplexWarning: Casting complex values to real discards the imaginary part
:   pts[N+2:, 1] = dep2slice[::-1]
[[file:./.ob-jupyter/045efebdb7009899f180780898a31b7f6c48e106.svg]]
:END:


#+begin_src jupyter-python
  fig, ax = plt.subplots()
  ax.set_xlim(models[0].Θ * 2, models[0].Θ * 3)


  for i, model in enumerate(models[len(Ts) : 2*len(Ts)]):
      ω_c = model.ω_c[0]
      pu.plot_with_σ(
          model.t,
          model.interaction_energy().for_bath(0),
          ax=ax,
          color=f"C{i}",
          label=f"{model.T[0]}",
      )
      pu.plot_with_σ(
          model.t,
          model.interaction_energy().for_bath(1),
          ax=ax,
          color=f"C{i}",
          linestyle="dotted",
      )
      pu.plot_with_σ(
          model.t, model.system_energy(), ax=ax, linestyle="dashed", color=f"C{i}"
      )

      # ax.plot(model.t, model.coupling_operators[0].operator_norm(model.t), linestyle="dashed", color=f"C{i}")
      # ax.plot(model.t, model.system.operator_norm(model.t), linestyle="dashed", color=f"C{i}")
      # pu.plot_with_σ(model.t, model.interaction_power().for_bath(1), ax=ax, linestyle="dashed")

  custom_lines = [
      Line2D([0], [0], linestyle=style, color="black")
      for style in ["-", "dotted", "dashed"]
  ]
  legend_orig = fig.legend(title=r"$T_c$", loc="upper center", bbox_to_anchor=[1.1, 0.7])
  fig.legend(
      custom_lines,
      [
          r"$\langle H_{\mathrm{I},c}\rangle$",
          r"$\langle H_{\mathrm{I},h}\rangle$",
          r"$\langle H_{\mathrm{S}}\rangle$",
      ],
      loc="upper center",
      bbox_to_anchor=[1.1, 1],
  )
  fig.add_artist(legend_orig)
  ax.set_title(rf"$\omega_c={ω_c}$")
  ax.set_xlabel(r"$\tau$")

  fs.export_fig("bath_memory_constant_omega_overview", x_scaling=1, y_scaling=0.7)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/2a877ebd7c84b122825c60319a419fe5cd199876.svg]]


#+begin_src jupyter-python
  ot.plot_powers_and_efficiencies(np.array(ωs), models[0::len(Ts)], xlabel=r"$\omega_c$")
#+end_src

#+RESULTS:
:RESULTS:
| <Figure | size | 340x320 | with | 2 | Axes> | <AxesSubplot: | xlabel= | $\omega_c$ | ylabel= | $\bar{P}$ | > | (<AxesSubplot: xlabel= $\omega_c$ ylabel= $\bar{P}$ > <AxesSubplot: ylabel= $\eta$ >) |
[[file:./.ob-jupyter/6eccb61abca525820e2df7e9a93704f42eefc925.svg]]
:END:



#+begin_src jupyter-python
  ot.plot_power_eff_convergence(models, 2)
#+end_src

#+RESULTS:
:RESULTS:
: [WARNING root                      241349] Adding values with unequal snapshot count discards the snapshots.
: [WARNING root                      241349] Adding values with unequal snapshot count discards the snapshots.
: [WARNING root                      241349] Adding values with unequal snapshot count discards the snapshots.
: [WARNING root                      241349] Adding values with unequal snapshot count discards the snapshots.
: [WARNING root                      241349] Adding values with unequal snapshot count discards the snapshots.
: [WARNING root                      241349] Adding values with unequal snapshot count discards the snapshots.
| <Figure | size | 340x320 | with | 2 | Axes> | (<AxesSubplot: xlabel= $N$ ylabel= $P$ > <AxesSubplot: xlabel= $N$ ylabel= $\eta$ >) |
[[file:./.ob-jupyter/c11f1a91e2f5aff480076974436ee62a17d4f1be.svg]]
:END:



#+begin_src jupyter-python
  f = plt.figure()
  a_power = f.add_subplot(121, projection="3d")
  a_efficiency = f.add_subplot(122, projection="3d")

  for ax in [a_power, a_efficiency]:
      ax.set_box_aspect(aspect=None, zoom=0.78)
      ax.set_xlabel(r"$T_c$")
      ax.set_ylabel(r"$\omega_c$")
      ax.xaxis.labelpad = 10
      ax.view_init(elev=30.0, azim=-29, roll=0)

  ot.plot_3d_heatmap(
      models,
      lambda model: np.clip(-model.power(steady_idx=2).value, 0, np.inf),
      lambda model: model.T[0],
      lambda model: model.ω_c[0],
      ax=a_power,
  )
  a_power.set_zlabel(r"$\bar{P}$")


  ot.plot_3d_heatmap(
      models,
      lambda model: np.clip(np.nan_to_num(model.efficiency(steady_idx=2).value * 100), 0, np.inf),
      lambda model: model.T[0],
      lambda model: model.ω_c[0],
      ax=a_efficiency,
  )
  a_efficiency.set_zlabel(r"$\eta$")
  fs.export_fig("bath_memory_power_efficiency", x_scaling=2, y_scaling=1)
#+end_src

#+RESULTS:
:RESULTS:
: [WARNING root                      269253] Adding values with unequal snapshot count discards the snapshots.
: [WARNING root                      269253] Adding values with unequal snapshot count discards the snapshots.
: [WARNING root                      269253] Adding values with unequal snapshot count discards the snapshots.
: [WARNING root                      269253] Dividing values with unequal snapshot count discards the snapshots.
: [WARNING root                      269253] Adding values with unequal snapshot count discards the snapshots.
: [WARNING root                      269253] Dividing values with unequal snapshot count discards the snapshots.
[[file:./.ob-jupyter/9f7b5b9ac4f5aeaf6b4769542196b14333e652d3.svg]]
:END:

#+begin_src jupyter-python
  for model in models:
      ot.plot_bloch_components(model)
#+end_src


#+RESULTS:
:RESULTS:
: /home/hiro/Documents/Projects/UNI/master/eflow_paper/python/otto_motor/subprojects/bath_memory/plot_utils.py:38: RuntimeWarning: More than 20 figures have been opened. Figures created through the pyplot interface (`matplotlib.pyplot.figure`) are retained until explicitly closed and may consume too much memory. (To control this warning, see the rcParam `figure.max_open_warning`). Consider using `matplotlib.pyplot.close()`.
:   fig, ax = setup_function()
[[file:./.ob-jupyter/7b586b9d458aae65d6bb03350905bc132f897b19.svg]]
[[file:./.ob-jupyter/7312898112e29a7fbe0c551bdea7727170f51aa5.svg]]
[[file:./.ob-jupyter/ab1364d48bac7a0407d12bfc571ff22839ef0b9e.svg]]
[[file:./.ob-jupyter/5130570263d371cf29b5f885fbe3a17b14e1525c.svg]]
[[file:./.ob-jupyter/ec66deb9232d33e038fc9d7695eafbbc66fd32b6.svg]]
[[file:./.ob-jupyter/8a4fb84fa9e3403cc504bf346399d716a3632874.svg]]
[[file:./.ob-jupyter/66a6c0a8155fb358ddaff688faf0b9688d811970.svg]]
[[file:./.ob-jupyter/aac1cd42fcea2716c112f423674620996e971b51.svg]]
[[file:./.ob-jupyter/b2474a687485dd0c5ef432bab65577445bfb3af8.svg]]
[[file:./.ob-jupyter/c05e38691ec6390fcb6a1d348ad676f7f1593f95.svg]]
[[file:./.ob-jupyter/bdf956f38937df3eea83c24b78b56a39c53c94c9.svg]]
[[file:./.ob-jupyter/b869d7a4f7c8ef6ea1ec832172c6e9f0874e52e4.svg]]
[[file:./.ob-jupyter/69d46626832953e6cef4eaa7588057bb340a35e5.svg]]
[[file:./.ob-jupyter/e23c99ac76f0c7171ffc8928c0826506a06c4105.svg]]
[[file:./.ob-jupyter/f771cb1d92e5dedbba4ff856543ca0e59b5b3fee.svg]]
[[file:./.ob-jupyter/e06ab97aff6d6f97a0025e3c9fd47ccf4ba1e06c.svg]]
[[file:./.ob-jupyter/4b60282e07356bc7faa706d37adf0469093142fe.svg]]
[[file:./.ob-jupyter/eb6bb6240be7c02c5d3f7f6cb2e16fbf26715d62.svg]]
[[file:./.ob-jupyter/6b03ad3f30e07aeeb96fa1337d6343a413ddadda.svg]]
[[file:./.ob-jupyter/50b37a6e55de4c46d338671cb9701a4368de9743.svg]]
[[file:./.ob-jupyter/8fa686381fd81aa7a62f133814ebc30d55d74c65.svg]]
[[file:./.ob-jupyter/0ce1c995679c905cf03f5f22b77d170c6bb36256.svg]]
[[file:./.ob-jupyter/fc83287a59e890e937b19644ee4280935950fc9a.svg]]
[[file:./.ob-jupyter/b344bce75b6a4a7600eea5af656816936e75fef1.svg]]
[[file:./.ob-jupyter/7e601568d54a636a176925f29f8bd289530c643b.svg]]
:END:

* Things to Look At
- power and efficiency
- interaction power
