#+PROPERTY: header-args :session bath_memory :kernel python :pandoc no :async yes :tangle tangle/bath_memory.py

Here we scan bath memory and maybe temperature gradient later.

* Boilerplate
#+name: boilerplate
#+begin_src jupyter-python :results none
  import figsaver as fs
  import plot_utils as pu
  from hiro_models.one_qubit_model import StocProcTolerances
  from hiro_models.otto_cycle import OttoEngine
  import hiro_models.model_auxiliary as aux
  import numpy as np
  import qutip as qt
  import utilities as ut
  import stocproc
  import matplotlib.pyplot as plt
  import otto_utilities as ot

  import ray
  ray.shutdown()

  #ray.init(address='auto')
  ray.init()
  from hops.util.logging_setup import logging_setup
  import logging
  logging_setup(logging.INFO)
  plt.rcParams['figure.figsize'] = (12,4)
#+end_src

* Cycles
We take the same baseline as in [[id:c06111fd-d719-433d-a316-c163f6e1d384][cycle_shift.org]].


But we vary the cycle speed while keeping a fixed proportion
coupling-change/cycle time.
#+begin_src jupyter-python
  T = 50
  def make_model_orig(shift_c, shift_h, switch_t=6.0, switch_t_sys=None, only_cold=False):
      switch_time = switch_t / T
      switch_time_sys = (switch_t_sys if switch_t_sys else switch_t) / T

      (p_H, p_L) = ot.timings(switch_time_sys, switch_time)
      return OttoEngine(
          δ=[0.7, 0.7],
          ω_c=[1, 1],
          ψ_0=qt.basis([2], [1]),
          description=f"Classic Cycle",
          k_max=4,
          bcf_terms=[5] * 2,
          truncation_scheme="simplex",
          driving_process_tolerances=[StocProcTolerances(1e-3, 1e-3)] * 2,
          thermal_process_tolerances=[StocProcTolerances(1e-3, 1e-3)] * 2,
          T=[0.5, 4],
          therm_methods=["tanhsinh", "tanhsinh"],
          Δ=1,
          num_cycles=3,
          Θ=60,
          dt=0.001,
          timings_H=p_H,
          timings_L=p_L,
          streaming_mode=True,
          shift_to_resonance=(False, False),
          L_shift=(shift_c, 0 if only_cold else shift_h),
      )

  def make_model(ω_c, T_c):
      model =  make_model_orig(0, 0, switch_t = 6)


      model.T[0] = T_c
      model.ω_c = [ω_c, ω_c]
      return model
#+end_src

#+RESULTS:


#+begin_src jupyter-python
  ωs = [round(ω, 3) for ω in np.linspace(.5, 1.5, 5)]
  Ts = [round(T, 3) for T in np.linspace(.4, .6, 5)]
  ωs, Ts
#+end_src

#+RESULTS:
| 0.5 | 0.75 | 1.0 | 1.25 | 1.5 |
| 0.4 | 0.45 | 0.5 | 0.55 | 0.6 |

#+begin_src jupyter-python
  import itertools
  models = [make_model(ω, T) for ω, T, in itertools.product(ωs, Ts)]
#+end_src

#+RESULTS:


* Integrate
#+begin_src jupyter-python
  ot.integrate_online_multi(models, 30_000, increment=10_000, analyze_kwargs=dict(every=10_000))
#+end_src

* Analysis
#+begin_src jupyter-python
  models[1].T
#+end_src

#+RESULTS:
| 0.45 | 4 |

#+begin_src jupyter-python
  fig, ax = plt.subplots()
  for model in models[:22]:
      pu.plot_with_σ(models[0].t, model.interaction_power().sum_baths().integrate(model.t), ax=ax)
      print(model.power(steady_idx=2).value, model.T[0], model.ω_c[0])
#+end_src

#+RESULTS:
:RESULTS:
#+begin_example
  -0.006066419789176171 0.4 0.5
  -0.005586445662789428 0.45 0.5
  -0.005038545160476334 0.5 0.5
  -0.004551607899071748 0.55 0.5
  -0.004084369471683145 0.6 0.5
  -0.006276938479392601 0.4 0.75
  -0.005883213741945448 0.45 0.75
  -0.0054760722009299465 0.5 0.75
  -0.00509961243651586 0.55 0.75
  -0.004713792601165993 0.6 0.75
  -0.006003694926219254 0.4 1.0
  -0.005630008851490323 0.45 1.0
  -0.005247723184476385 0.5 1.0
  -0.004922650999264568 0.55 1.0
  -0.004561986692017902 0.6 1.0
  -0.005792018673164359 0.4 1.25
  -0.005411940557486204 0.45 1.25
  -0.005122848900745669 0.5 1.25
  -0.004739985218211038 0.55 1.25
  -0.004424832509632545 0.6 1.25
  -0.005671859616295697 0.4 1.5
  -0.005321236317782547 0.45 1.5
#+end_example
[[file:./.ob-jupyter/917c1ebe76592c18cce8b87737189b95b83c50db.svg]]
:END:

#+begin_src jupyter-python
  fig, ax = plt.subplots()
  for model in models[:22]:
    pu.plot_with_σ(models[0].t, model.system_energy(), ax=ax)
#+end_src

#+RESULTS:


#+begin_src jupyter-python
  pu.plot_with_σ(models[0].t, models[0].interaction_power().sum_baths().integrate(models[0].t))
#+end_src

#+RESULTS:
:RESULTS:
| <Figure | size | 340x320 | with | 1 | Axes> | <AxesSubplot: | > | ((<matplotlib.lines.Line2D at 0x7efe37c44190>) <matplotlib.collections.PolyCollection at 0x7efe37c44400>) |
[[file:./.ob-jupyter/ab54ecc61173b390e1ce63542f07af12649117dd.svg]]
:END:


#+begin_src jupyter-python
  ot.plot_power_eff_convergence(models[:10], 2)
#+end_src

#+RESULTS:
:RESULTS:
| <Figure | size | 340x320 | with | 2 | Axes> | (<AxesSubplot: xlabel= $N$ ylabel= $P$ > <AxesSubplot: xlabel= $N$ ylabel= $\eta$ >) |
[[file:./.ob-jupyter/d61ecf7ba68b6c20786353099fd031aa665f86aa.svg]]
:END:



#+begin_src jupyter-python
  f = plt.figure()
  a_power = f.add_subplot(121, projection="3d")
  a_efficiency = f.add_subplot(122, projection="3d")

  for ax in [a_power, a_efficiency]:
      ax.set_box_aspect(aspect=None, zoom=0.7)
      ax.set_xlabel(r"$T_c$")
      ax.set_ylabel(r"$\omega_c$")
      ax.xaxis.labelpad = 10
      ax.view_init(elev=30.0, azim=-29, roll=0)

  ot.plot_3d_heatmap(
      models[:20],
      lambda model: np.clip(-model.power(steady_idx=2).value, 0, np.inf),
      lambda model: model.T[0],
      lambda model: model.ω_c[0],
      ax=a_power,
  )
  a_power.set_zlabel(r"$P$")


  ot.plot_3d_heatmap(
      models[:20],
      lambda model: np.clip(np.nan_to_num(model.efficiency(steady_idx=2).value * 100), 0, np.inf),
      lambda model: model.T[0],
      lambda model: model.ω_c[0],
      ax=a_efficiency,
  )
  a_efficiency.set_zlabel(r"$\eta$")
  fs.export_fig("bath_memory_power_efficiency", x_scaling=2, y_scaling=1)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/59482d74634fe63bcb6cc489dfb1b792da1c169a.svg]]

#+begin_src jupyter-python
  for model in models:
      ot.plot_bloch_components(model)
#+end_src

#+RESULTS:
:RESULTS:
: /home/hiro/Documents/Projects/UNI/master/eflow_paper/python/otto_motor/subprojects/bath_memory/plot_utils.py:38: RuntimeWarning: More than 20 figures have been opened. Figures created through the pyplot interface (`matplotlib.pyplot.figure`) are retained until explicitly closed and may consume too much memory. (To control this warning, see the rcParam `figure.max_open_warning`). Consider using `matplotlib.pyplot.close()`.
:   fig, ax = setup_function()
[[file:./.ob-jupyter/ca6f8c77e0d1c2c4c0588a27f1d5a73f06959b28.svg]]
[[file:./.ob-jupyter/9f04f59f958f8cd05e7fcfae012822448e28a0fa.svg]]
[[file:./.ob-jupyter/7e64dd5c305b62d7e61c8d54061ba0d5c0bd9c71.svg]]
[[file:./.ob-jupyter/a1049ebdd7cfc3033bda8fa6d8db69c76b10c5d4.svg]]
[[file:./.ob-jupyter/6f7c25ffff1125b68ed93c42984b3fbdbc623e4f.svg]]
[[file:./.ob-jupyter/bd8ed043725eac4e7087ce04a8f79cb6dd550bea.svg]]
[[file:./.ob-jupyter/b9f416d4b1330798fc77fc4e38c6ec544c84a2ad.svg]]
[[file:./.ob-jupyter/b7f019626c425b7fd2e28f1d70953cd433a26848.svg]]
[[file:./.ob-jupyter/fdde454c6d1a1e31736ab2f26b35c64424e217f3.svg]]
[[file:./.ob-jupyter/e0af7e1701860e27f7e3fe45f05b8c7c7bf21925.svg]]
[[file:./.ob-jupyter/af151eefe6085deb9679052c683cd68c4d511ade.svg]]
[[file:./.ob-jupyter/28b0b7edde79a9c047b455633716a30c742dcd8f.svg]]
[[file:./.ob-jupyter/471db72082118a478b1ca5e58ac27511fdb93ad5.svg]]
[[file:./.ob-jupyter/66c1ff99f83e6c30af2feb9341d02522d77dde69.svg]]
[[file:./.ob-jupyter/623e14113817b5d8f1074943abccdb7caa0c0bb0.svg]]
[[file:./.ob-jupyter/675689df6d994ce4b35bb864a382f9d7d285b248.svg]]
[[file:./.ob-jupyter/1ac491c0d095e16d95afe9602af94955acde385f.svg]]
[[file:./.ob-jupyter/41bcaaaa18868654a7a90a5f911a994028d3d3e8.svg]]
[[file:./.ob-jupyter/0bc90e1a20c538d634aa21afed202d1c2648222a.svg]]
[[file:./.ob-jupyter/b4790ef001a8c49fdf9a178196428c3ccdb95d25.svg]]
[[file:./.ob-jupyter/70822f7bcdb6cffa813ca2c828a59e6b3307d4ef.svg]]
[[file:./.ob-jupyter/7bcf53ab551180350c7516d1cd29b3c0608229b7.svg]]
[[file:./.ob-jupyter/6375902d049d7c66e42fc1ef593ce9a109b5992c.svg]]
[[file:./.ob-jupyter/9911ddfe7318ac880f7254510fc9dd449cf1a11d.svg]]
[[file:./.ob-jupyter/2b14a9fdd7d143dbeeba0b108a2df8c49e853c01.svg]]
:END:

* Things to Look At
- power and efficiency
- interaction power
